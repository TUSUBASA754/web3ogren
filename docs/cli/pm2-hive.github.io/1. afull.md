---
description: PM2, uygulamanızı yönetmenize yardımcı olan bir daemon süreç yöneticisidir. Başlangıçtan uygulama yönetimine kadar kapsamlı bir rehber sunmaktadır.
keywords: [PM2, süreç yönetimi, uygulama yönetimi, sunucu yönetimi, Node.js]
---

# PM2 Nedir?

PM2, uygulamanızı yönetmenize ve çevrimiçi tutmanıza yardımcı olacak bir daemon süreç yöneticisidir. PM2 ile başlamak oldukça basittir; NPM aracılığıyla yüklenebilen basit ve sezgisel bir CLI olarak sunulmaktadır.

### Kurulum

En son PM2 sürümünü NPM veya Yarn ile yükleyebilirsiniz:

```bash
$ npm install pm2@latest -g
# veya
$ yarn global add pm2
```

Node.js ve NPM'i yüklemek için [NVM](https://yoember.com/nodejs/the-best-way-to-install-node-js/) kullanabilirsiniz.

### Uygulama Başlatma

Uygulamanızı başlatmak, daemonize etmek ve izlemek için en basit yol bu komut satırını kullanmaktır:

```bash
$ pm2 start app.js
```

Ya da kolayca başka bir uygulama başlatın:

```bash
$ pm2 start bashscript.sh
$ pm2 start python-app.py --watch
$ pm2 start binary-file -- --port 1520
```

:::tip
CLI'ye geçirebileceğiniz bazı seçenekler:
:::

```bash
# Uygulama adı belirtme
--name <app_name>

# Dosyalar değiştiğinde uygulamayı izle ve yeniden başlat
--watch

# Uygulama yeniden yüklemesi için bellek eşiğini ayarlama
--max-memory-restart <200MB>

# Günlük dosyasını belirt
--log <log_path>

# Betiğe ekstra argümanlar geç
-- arg1 arg2 arg3

# Otomatik yeniden başlatmalar arasındaki gecikme
--restart-delay <delay in ms>

# Günlükleri zamanla ön ekle
--time

# Uygulamayı otomatik olarak yeniden başlatma
--no-autorestart

# Zorunlu yeniden başlatma için cron belirt
--cron <cron_pattern>

# Uygulama günlüğüne ekle
--no-daemon
```

PM2 ile uygulamanızı yönetmek için pek çok seçeneğin mevcut olduğunu görebilirsiniz. Kullanım durumunuza bağlı olarak bunları keşfedeceksiniz.

## Süreçleri Yönetme

Uygulama durumunu yönetmek basittir; işte komutlar:

```bash
$ pm2 restart app_name
$ pm2 reload app_name
$ pm2 stop app_name
$ pm2 delete app_name
```

> `app_name` yerine geçirebileceğiniz değerler:
> - `all`, tüm süreçler üzerinde işlem yapmak için
> - `id`, belirli bir süreç kimliği üzerinde işlem yapmak için

## Durumu Kontrol Etme, Günlükler, Metrikler

Bu uygulamayı başlattığınızda, durumunu, günlüklerini, metriklerini kontrol edebilir ve hatta pm2.io ile çevrimiçi gösterge panelini alabilirsiniz.

### Yönetilen Uygulamaları Listeleme

PM2 tarafından yönetilen tüm uygulamaların durumunu listeleyin:

```bash
$ pm2 [list|ls|status]
```

![https://i.imgur.com/LmRD3FN.png](https://i.imgur.com/LmRD3FN.png)

### Günlükleri Görüntüleme

Gerçek zamanlı günlükleri görüntülemek için:

```bash
$ pm2 logs
```

Eski günlüklere göz atmak için:

```bash
$ pm2 logs --lines 200
```

### Terminal Tabanlı Gösterge Paneli

Terminalinize doğrudan sığacak bir gerçek zamanlı gösterge panelidir:

```bash
$ pm2 monit
```

![https://i.imgur.com/xo0LDb7.png](https://i.imgur.com/xo0LDb7.png)

### pm2.io: İzleme ve Teşhis Web Arayüzü

Web tabanlı gösterge paneli, tanılama sistemiyle birlikte:

```bash
$ pm2 plus
```

![https://i.imgur.com/sigMHli.png](https://i.imgur.com/sigMHli.png)

## Küme Modu

Node.js uygulamaları için PM2, her bir oluşturulan süreç arasında tüm HTTP[s]/Websocket/TCP/UDP bağlantılarını paylaşacak otomatik bir yük dengeleyici içerir.

Bir uygulamayı Küme modunda başlatmak için:

```bash
$ pm2 start app.js -i max
```

Küme modu hakkında daha fazla bilgi `burada` bulunmaktadır.

## Ekosistem Dosyası

Birden fazla uygulamayı yönetmek için Ekosistem Dosyası olarak adlandırılan bir yapılandırma dosyası oluşturabilirsiniz. Bir Ekosistem dosyası oluşturmak için:

```bash
$ pm2 ecosystem
```

Bu, bir `ecosystem.config.js` dosyası oluşturur:

```javascript
module.exports = {
  apps : [{
    name: "app",
    script: "./app.js",
    env: {
      NODE_ENV: "development",
    },
    env_production: {
      NODE_ENV: "production",
    }
  }, {
    name: 'worker',
    script: 'worker.js'
  }]
}
```

Ve bunu kolayca başlatın:

```bash
$ pm2 start ecosystem.config.js
```

Uygulama bildirimi hakkında daha fazla bilgi edinmek için `burada` okuyabilirsiniz.

## Başlangıç Betiği Ayarlama

Yönetmekte olduğunuz süreçlerle PM2'yi sunucu önyüklemesi/yeniden başlatması ile yeniden başlatmak kritik öneme sahiptir. Bunu çözmek için, aktif bir başlangıç betiği oluşturmak için şu komutu çalıştırın:

```bash
$ pm2 startup
```

Ve otomatik yeniden doğuş için bir süreç listesini dondurmak için:

```bash
$ pm2 save
```

Başlangıç betiği jeneratörü hakkında daha fazla bilgi için `burada` okuyabilirsiniz.

## Değişikliklerde Uygulamayı Yeniden Başlatma

`--watch` seçeneği ile oldukça kolaydır:

```bash
$ cd /path/to/my/app
$ pm2 start env.js --watch --ignore-watch="node_modules"
```

Bu, mevcut dizinden ve tüm alt klasörlerden dosya değişikliklerini izler ve uygulamayı yeniden başlatır; ayrıca `--ignore-watch="node_modules"` ile `node_modules` klasöründeki herhangi bir değişikliği göz ardı eder.

Yeniden başlatılan uygulama günlüklerini kontrol etmek için `pm2 logs` komutunu kullanabilirsiniz.

## PM2'yi Güncelleme

Bunu basit hale getirdik; sürümler arasında herhangi bir kırıcı değişiklik yoktur ve prosedür oldukça basittir:

```bash
$ npm install pm2@latest -g
```

Ardından bellekteki PM2'yi güncelleyin:

```bash
$ pm2 update
```

## Kısayol

Bilmeniz gereken bazı komutlar. Bunları örnek bir uygulama veya geliştirme makinenizdeki mevcut web uygulamanızla deneyin:

```bash
# Fork modu
pm2 start app.js --name my-api # Süreç adı

# Küme modu
pm2 start app.js -i 0        # Kullanılabilir CPU'ya bağlı maksimum süreç başlatacak
pm2 start app.js -i max      # Yukarıdaki ile aynı, ancak kullanımdan kaldırılmış.
pm2 scale app +3             # `app`'i 3 işçi artı yükseltir
pm2 scale app 2              # `app`'i toplamda 2 işçiye artırır veya azaltır

# Listeleme

pm2 list               # Tüm süreç durumunu görüntüler
pm2 jlist              # Ham JSON formatında süreç listesini yazdırır
pm2 prettylist         # Göz alıcı JSON formatında süreç listesini yazdırır

pm2 describe 0         # Belirli bir süreç hakkında tüm bilgileri gösterir

pm2 monit              # Tüm süreçleri izler

# Günlükler

pm2 logs [--raw]       # Tüm süreç günlüklerini akış halinde görüntüler
pm2 flush              # Tüm günlük dosyalarını boşaltır
pm2 reloadLogs         # Tüm günlükleri yeniden yükler

# Eylemler

pm2 stop all           # Tüm süreçleri durdur
pm2 restart all        # Tüm süreçleri yeniden başlat

pm2 reload all         # 0s kesinti ile yeniden yükleme (AĞ BAĞLI uygulamalar için)

pm2 stop 0             # Belirli bir süreç kimliğini durdur
pm2 restart 0          # Belirli bir süreç kimliğini yeniden başlat

pm2 delete 0           # Süreci pm2 listesinden kaldırır
pm2 delete all         # Tüm süreçleri pm2 listesinden kaldırır

# Diğer

pm2 reset <process>    # Meta verileri sıfırlar (yeniden başlatma saati...)
pm2 updatePM2          # Bellekteki pm2'yi günceller
pm2 ping               # pm2 daemon'ın başlatılmış olduğundan emin olun
pm2 sendSignal SIGUSR2 my-app # Betiğe sistem sinyali gönder
pm2 start app.js --no-daemon
pm2 start app.js --no-vizion
pm2 start app.js --no-autorestart
```

## Sonraki Adımlar Neler?

Tüm uygulama davranış seçeneklerinizi bir [JSON yapılandırma dosyası](http://pm2.keymetrics.io/docs/usage/application-declaration/) içine nasıl bildireceğinizi öğrenin.

Güvenilirliği artırmak için [temiz durdurma ve yeniden başlatma](http://pm2.keymetrics.io/docs/usage/signals-clean-restart/) işlemini nasıl yapacağınızı öğrenin.

Üretim uygulamalarını kolayca [dağıtma ve güncelleme](http://pm2.keymetrics.io/docs/usage/deployment/) hakkında bilgi alın.

Üretim uygulamalarınızı [PM2.io](https://app.pm2.io/) ile izleyin.

## PM2'yi Nasıl Güncellerim

En son PM2 sürümünü yükleyin:

```bash
$ npm install pm2@latest -g
```

Ardından bellekteki PM2'yi güncelleyin:

```bash
$ pm2 update
```

## Yapılandırma Dosyası

PM2 ile birden fazla uygulama yönetirken, bunları düzenlemek için bir JS yapılandırma dosyası kullanın.

### Yapılandırma Oluşturma

Örnek bir yapılandırma dosyası oluşturmak için bu komutu yazabilirsiniz:

```bash
$ pm2 init simple
```

Bu, örnek bir `ecosystem.config.js` oluşturacaktır:

```javascript
module.exports = {
  apps : [{
    name   : "app1",
    script : "./app.js"
  }]
}
```

Kendi yapılandırma dosyanızı oluşturuyorsanız, PM2'nin bunu bir yapılandırma dosyası olarak tanıyabilmesi için `.config.js` ile bitmesini sağlayın.

### Yapılandırma Dosyasında İşlem Yapma

Bir uygulama üzerinde işlem yapmak yerine, bir yapılandırma dosyasında bulunan tüm uygulamaları başlat/durdur/yeniden başlat/sil işlemini kolaylıkla gerçekleştirebilirsiniz:

```bash
# Tüm uygulamaları başlat
pm2 start ecosystem.config.js

# Hepsini durdur
pm2 stop ecosystem.config.js

# Hepsini yeniden başlat
pm2 restart ecosystem.config.js

# Hepsini yeniden yükle
pm2 reload ecosystem.config.js

# Hepsini sil
pm2 delete ecosystem.config.js
```

#### Belirli Bir Süreç Üzerinde İşlem Yapma

`--only ` seçeneğini kullanarak belirli bir uygulama üzerinde de işlem yapabilirsiniz:

```bash
pm2 start ecosystem.config.js --only api-app
```

*Not*: `--only` seçeneği, başlatma/yeniden başlatma/durdurma/silme için de geçerlidir.

Belli başlı uygulamalar üzerinde işlem yapmak için her bir uygulama ismini virgül ile ayırarak belirtebilirsiniz:

```bash
pm2 start ecosystem.config.js --only "api-app,worker-app"
```

### Ortamları Değiştirme

`env_*` seçeneği aracılığıyla farklı ortam değişkeni setleri belirtebilirsiniz.

Örnek:

```javascript
module.exports = {
  apps : [{
    name   : "app1",
    script : "./app.js",
    env_production: {
       NODE_ENV: "production"
    },
    env_development: {
       NODE_ENV: "development"
    }
  }]
}
```

Şimdi farklı ortamda değişkenler arasında geçiş yapmak için `--env [env name]` seçeneğini belirtin:

```bash
pm2 start process.json --env production
pm2 restart process.json --env development
```

## Mevcut Özellikler

Uygulama davranışı ve yapılandırması, aşağıdaki özelliklerle ince ayar yapılabilir:

### Genel

|  Alan  |  Tür  |  Örnek |  Açıklama|
|:------|:-----:|:------------------------------:|:-------------------------|
|name   | (string)   | "my-api" | uygulama adı (uzantısız betik dosyası adına varsayılan)|
|script| (string)    | "./api/app.js" | pm2 start'a göre betik yolu|
|cwd| (string)       | "/var/www/" | uygulamanızın başlatılacağı dizin|
|args| (string)      | "-a 13 -b 12" | CLI üzerinden betiğe geçirilen tüm argümanları içeren dize|
|interpreter| (string) | "/usr/bin/python" | yorumlayıcının mutlak yolu (varsayılan olarak node)|
|interpreter_args| (string) | "--harmony" | yorumlayıcıya geçirilen seçenek|
|node_args| (string) |   | yorumlayıcı_args'a takma ad |

### Gelişmiş Özellikler

|  Alan  |  Tür  |  Örnek |  Açıklama|
|:------|:-----:|:------------------------------:|:-------------------------|
|instances | number | -1 | başlatılacak uygulama örneği sayısı |
|exec_mode | string | "cluster" | uygulamanızı başlatma modu; "cluster" veya "fork" olabilir, varsayılan olarak fork|
| watch   | boolean veya [] |  true |  izleme ve yeniden başlatma özelliğini etkinleştirir; bir dosya veya alt klasörde bir değişiklik olduğunda, uygulamanız yeniden yüklenir |
|    ignore_watch    |   liste  |     ["[\\/\\\\]\\./", "node_modules"]     | izleme özelliğiyle bazı dosya veya klasör adlarını göz ardı etmek için regex listesi|
| max_memory_restart |  string |  "150M" |  belirsiz bir miktar bellek aşılırsa uygulamanız yeniden başlatılacak. kullanıcı dostu format: "10M", "100K", "2G" vb. gibi |
| env |  nesne |   {"NODE_ENV": "development", "ID": "42"}  | uygulamanızda görünecek ortam değişkenleri |
| env_ |  nesne |   {"NODE_ENV": "production", "ID": "89"}  | pm2 restart app.yml --env  yaptığınızda 'i enjekte eder|
| source_map_support | boolean |  true | varsayılan olarak true, [kaynak haritası dosyasını etkinleştir/devre dışı bırak] |
| instance_var | string | "NODE_APP_INSTANCE" | [belgeleri gör] (http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables)|
| filter_env | string dizisi | [ "REACT_" ] | "REACT_" ile başlayan global değişkenleri hariç tutar ve küme içine sızmalarını engeller. |

### Günlük Dosyaları

|  Alan  |  Tür  |  Örnek |  Açıklama|
|:------|:-----:|:------------------------------:|:-------------------------|
|log_date_format| (string) | "YYYY-MM-DD HH:mm Z" | günlük tarih formatı (günlük bölümü için bakın)|
|error_file| (string)| | hata dosyası yolu (varsayılan olarak $HOME/.pm2/logs/&lt;app name&gt;-error-&lt;pid&gt;.log)|
|out_file| (string) | | çıktı dosyası yolu (varsayılan olarak $HOME/.pm2/logs/&lt;app name&gt;-out-&lt;pid&gt;.log)|
|log_file| (string) | | hem çıktı hem de hata günlük dosyası yolu (varsayılan olarak devre dışı bırakılır)|
|combine_logs| boolean | true | true olarak ayarlandığında, günlük dosyalarını süreç kimliği ile sonlandırmamaya yönelik |
|merge_logs| boolean | true | combine_logs için takma ad |
|pid_file| (string) | | pid dosyası yolu (varsayılan olarak $HOME/.pm2/pids/&lt;app name&gt;-&lt;pid&gt;.pid)|

### Kontrol Akışı

|  Alan  |  Tür  |  Örnek |  Açıklama|
|:------|:-----:|:------------------------------:|:-------------------------|
|min_uptime| (string) | | başlatılmış olarak kabul edilmesi için uygulamanın minimum çalışma süresi |
| listen_timeout | number | 8000 | uygulama dinlemediğinde yeniden yükleme zorlamak için ms cinsinden süre |
| kill_timeout | number | 1600 | [son bir SIGKILL](http://pm2.keymetrics.io/docs/usage/signals-clean-restart/#cleaning-states-and-jobs) gönderilmeden önce geçen süre (milisaniye cinsinden) |
| shutdown_with_message | boolean | false | uygulamayı process.send('shutdown') ile kapatır; process.kill(pid, SIGINT) yerine |
| wait_ready | boolean | false | Yeniden yükleme dinleme olayını beklemek yerine, process.send('ready') bekler |
| max_restarts| number | 10 | art arda olağanüstü yeniden başlatmaların sayısı (1 sn aralığı veya min_uptime ile özel zaman) uygulamanız hatalı olarak kabul edildiğinde ve yeniden başlatma durur |
| restart_delay    | number |                    4000                   |                             çökme durumunda yeniden başlatmadan önce bekleme süresi (milisaniye cinsinden). varsayılan 0'dır.|
| autorestart | boolean |  false  |  varsayılan olarak true. false ise, PM2 çökmesi veya sorunsuz bitmesi durumunda uygulamanızı yeniden başlatmayacaktır |
| cron_restart    |  string |                "1 0 * * *"                |                                      uygulamanızı yeniden başlatmak için bir cron deseni. Uygulama cron özelliğinin çalışması için çalışıyor olmalıdır  |
| vizion       | boolean |                   false                   |  varsayılan olarak true. false ise, PM2 versiyonlama kontrolü için metadata olmadan başlatılacaktır |
| post_update    |   liste  | ["npm install", "echo launching the app"] |                                        bir Pull/Yükseltme işlemi gerçekleştirdikten sonra yürütülecek komutlar listesi |
| force       | boolean |                    true                   |                                          varsayılan olarak false. true ise, aynı betiği birkaç kez başlatabilirsiniz; bu genellikle PM2 tarafından izin verilmez |

### Dağıtım 

Giriş adı|Açıklama|Tür|Varsayılan
---|---|---|---
key|SSH anahtar yolu|String|$HOME/.ssh
user|SSH kullanıcı adı|String|
host|SSH anahtarı|[String]|
ssh_options|Komut satırı bayrağı olmayan SSH seçenekleri, 'man ssh'yi görün|String veya [String]|
ref|GIT uzaktan/şubesi|String|
repo|GIT uzantısı|String|
path|sunucudaki yol|String|
pre-setup| Yerel makinenizde bir komut veya betik yolunu ön ayarlamayı belirleyin|String|
post-setup|Ana makinedeki bir komut veya betik yolunu son ayarlamayı belirleyin|String
pre-deploy-local| ön dağıtım işlemi|String|
post-deploy| son dağıtım işlemi|String|

### Değerlendirmeler

JSON uygulama bildirimini kullanırken geçirilen tüm komut satırı seçenekleri bırakılacaktır, yani.

#### CWD

**cwd:** JSON bildiriminiz, betiğinizle birlikte yer almasına gerek yoktur. JSON'ları betiğinizden farklı bir konumda (örneğin, `/etc/pm2/conf.d/node-app.json`) tutmak istiyorsanız, `cwd` özelliğini kullanmalısınız (Not: bu, simgesel bağlantılar kullanan capistrano tarzı dizin yapıları için gerçekten yararlı olabilir). Dosyalar ya `cwd` dizinine göre göreceli veya mutlak olabilir (aşağıdaki örneğe bakın).

### CLI/JSON Seçenekleri

Tüm anahtarlar, bir JSON yapılandırma dosyasında kullanılabilir, ancak komut satırında hemen hemen aynı kalacaktır, örneğin:

```
exec_mode         -> --execute-command
max_restarts      -> --max-restarts
force             -> --force
```

Bir ESC yapmak için tırnak işareti kullanma, örneğin:

```bash
$pm2 start test.js --node-args "port=3001 sitename='first pm2 app'"
```

`nodeArgs` argümanı şöyle analiz edilecektir:

```JSON
[
  "port=3001",
  "sitename=first pm2 app"
]
```

Ama böyle değil:

```JSON
[
  "port=3001",
  "sitename='first",
  "pm2",
  "app'"
]
```

### Günlükleri Devre Dışı Bırakma

Günlükleri kaydetmeyi devre dışı bırakmak için `error_file` veya `out_file`'a `/dev/null` geçebilirsiniz.
Not: PM2'nin `2.4.0` sürümünden itibaren, `/dev/null` veya `NULL` günlükleri platformdan bağımsız olarak devre dışı bırakır.

### Günlükler Son Eki

Günlüklerde otomatik ID son eklerini devre dışı bırakabilir (örn. `app-name-ID.log`) ve `merge_logs: true` seçeneğini etkinleştirebilirsiniz.

### Ortam Tanımı

Belirli bir ortamın, bir süreç dosyasının içindeki belirli ortamları kullanmasını sağlamak için `--env ` kullanmanız gerekir:

```json
{
  "apps" : [{
    "name"        : "worker",
    "script"      : "./worker.js",
    "watch"       : true,
    "env": {
      "NODE_ENV": "development"
    },
    "env_production" : {
       "NODE_ENV": "production"
    }
  },{
    "name"       : "api-app",
    "script"     : "./api.js",
    "instances"  : 4,
    "exec_mode"  : "cluster"
  }]
}
```

Bu örnekte, `pm2 start ecosystem.json` komutunu çalıştıracak ve uygulamanızı varsayılan ortamda (geliştirme modunda) başlatacaktır.
Ardından `pm2 start ecosystem.json --env production` komutunu çalıştırarak `env_` niteliğini kullanabilirsiniz; burada `name` `production` olduğu için uygulamanızı `NODE_ENV=production` ile başlatacaktır.

### Özel `ext_type`

- min_uptime
  `min_uptime` değerinin şu şekilde olabileceği anlamına gelir:
    - **Sayı**
      örneğin, `"min_uptime": 3000` 3000 milisaniye demektir.
    - **Dize**
      Bu nedenle, bunu kısa ve kolay bir şekilde yapılandırıyoruz: `h`, `m` ve `s`, örneğin: `"min_uptime": "1h"` bir saat, `"min_uptime": "5m"` beş dakika, `"min_uptime": "10s"` on saniye anlamına gelir (bunlar milisaniyeye dönüşecektir).

- max_memory_restart
  `max_memory_restart` değerinin şu şekilde olabileceği anlamına gelir:
    - **Sayı**
        örneğin, `"max_memory_restart": 1024` 1024 bayt anlamına gelir (**BİT DEĞİL**).
    - **Dize**
        Bu nedenle, kısa ve kolay bir şekilde yapılandırıyoruz: `G`, `M` ve `K`, örneğin: `"max_memory_restart": "1G"` bir gigabayt, `"max_memory_restart": "5M"` beş megabayt, `"max_memory_restart": "10K"` on kilobayt anlamına gelir (bunlar byte olarak dönüşecektir).

- Opsiyonel Değerler
  Örneğin, `exec_mode` `cluster` (`cluster_mode`) veya `fork` (`fork_mode`) olarak değerler alabilir.

- Bilinmesi Gerekenler
  - `"instances": 0` PM2'nin mevcut CPU sayısına göre maksimum süreçleri başlatacağı anlamına gelir (küme modunda)
  - dizi
  `args`, `node_args` ve `ignore_watch` türleri `Array` (örn. `"args": ["--toto=heya coco", "-d", "1"]`) veya `string` (örn. `"args": "--to='heya coco' -d 1"`) olabilir.

## Küme Modu

**Küme Modu**, ağ tabanlı Node.js uygulamalarının (http(s)/tcp/udp sunucusu) kullanılabilir tüm CPU'lar arasında ölçeklenmesine olanak tanır; kod değişiklikleri beklemeden. Bu, uygulamanızın performansını ve güvenilirliğini artırır; bu durum kullanılabilir CPU sayısına bağlıdır. Temelini Node.js [cluster modülü](https://nodejs.org/api/cluster.html) kullanarak oluşturur; böylece ölçeklendirilen uygulamanın çocuk süreçleri otomatik olarak sunucu bağlantı noktaları paylaşabilir. Daha fazla bilgi edinmek için resmi Node.js belgelerinde [Nasıl Çalışır](https://nodejs.org/api/cluster.html#cluster_how_it_works) bölümüne bakın.

![http://i.imgur.com/kTAowsL.png](http://i.imgur.com/kTAowsL.png)

## Kullanım

**Küme Modunu** etkinleştirmek için sadece -i  seçeneğini geçirin:

```bash
pm2 start app.js -i max
```

`max`, PM2'nin mevcut CPU sayısını otomatik olarak algılayacağı ve mümkün olan en fazla süreci çalıştıracağı anlamına gelir.

Ya da bir [js/yaml/json dosyası](http://pm2.keymetrics.io/docs/usage/application-declaration/) aracılığıyla:

```javascript
module.exports = {
  apps : [{
    script    : "api.js",
    instances : "max",
    exec_mode : "cluster"
  }]
}
```

**NOT**: yük dengelemek istediğinizi PM2'nin bilmesi için `exec_mode`'yi `cluster` olarak ayarlamanız gerekir; varsayılan olarak bunu yapmaz.

Ardından süreç dosyasını başlatmak için:

```bash
pm2 start processes.json
```

*-i* veya *instances* seçeneği şu şekilde olabilir:
- **0/max**, uygulamayı tüm CPU'lar arasında yaymak için
- **-1**, uygulamayı tüm CPU'lar - 1 arasında yaymak için
- **sayı**, uygulamayı **sayı** CPU'su arasında yaymak için

---
description: PM2 ile uygulamaları yeniden yükleme, nazik kapatma ve dağıtım sistemlerini nasıl yönetebileceğinizi keşfedin. Ayrıca Docker entegrasyonu ve ortam değişkenleri gibi konulara da değinilmektedir.
keywords: [PM2, yeniden yükleme, nazik kapatma, dağıtım, Docker, ortam değişkenleri, stateless uygulama]
---

## Yeniden Yükleme

`restart` işlemden kaldırıp süreci yeniden başlattığı gibi, `reload` **0 saniye kesinti** ile bir yeniden yükleme gerçekleştirir.

Bir uygulamayı yeniden yüklemek için:

```bash
pm2 reload <app_name>
```

Veya:

```bash
pm2 reload process.json
pm2 reload process.json --only api
```

:::tip
Eğer yeniden yükleme sistemi uygulamanızı yeniden yüklemeyi başaramazsa, bir zaman aşımı klasik bir yeniden başlatmayı tercih eder.
:::

## Nazik Kapatma

Üretim ortamında, uygulamadan çıkmadan önce kalan sorguların işlenmesini beklemeniz veya tüm bağlantıları kapatmanız gerekebilir. *PM2 yeniden yükleme bağlamında* bu, çok uzun bir yeniden yükleme veya işe yaramayan bir yeniden yükleme (yeniden başlatmaya geri döner) olarak çevrilebilir, bu da uygulamanızın çıkışta hala açık bağlantılara sahip olduğu anlamına gelir. Alternatif olarak, tüm veritabanı bağlantılarını kapatmanız, veri kuyruklarını temizlemeniz veya başka bir şey yapmanız gerekebilir.

:::info
Bir uygulamayı nazik bir şekilde kapatmak için, **SIGINT** sinyalini yakalayabilir (PM2 tarafından çıkışta gönderilen ilk sinyal) ve tüm bu durumları beklemek/temizlemek için işlemler gerçekleştirebilirsiniz:
```javascript
process.on('SIGINT', function() {
   db.stop(function(err) {
     process.exit(err ? 1 : 0);
   });
});
```
:::

[Nazik Kapatma hakkında daha fazla bilgi edinin](http://pm2.keymetrics.io/docs/usage/signals-clean-restart/) özelliği.

---

## Uygulamanızı Stateless Hale Getirin

Uygulamanızın [**stateless**](http://pm2.keymetrics.io/docs/usage/specifics/#stateless-apps) olduğundan emin olun, bu, süreçte yerel veri saklanmadığı anlamına gelir, örneğin oturumlar/websocket bağlantıları, oturum belleği ve ilgili veriler. Durumları süreçler arasında paylaşmak için Redis, Mongo veya diğer veritabanlarını kullanın.

Verimli, üretime hazır stateless uygulama yazma hakkında başka bir kaynak [On İki Faktörlü Uygulama manifestosu](https://12factor.net/)dır.

---

## Katkıda Bulunma/Geliştirme Modu

PM2 ile oynamak çok basit:

```bash
pm2 kill   # mevcut pm2'yi öldür
git clone my_pm2_fork.git
cd pm2/
DEBUG=* ./bin/pm2 --no-daemon
```

Her seferinde kodu düzenlediğinizde, değişikliklerin etkili olması için PM2'yi öldürüp yeniden başlatmayı unutmayın.

:::note
**DEBUG="*"** Tüm olası hata ayıklama günlüklerini ~/.pm2/pm2.log dosyasında gösterir.
:::

---

## PM2 Geliştirme Kurulumu

```bash
npm install https://github.com/Unitech/pm2#development -g
```

## Testleri Başlatma

Master: [![Build Status](https://img.shields.io/travis/Unitech/pm2/master.svg?style=flat-square)](https://travis-ci.org/Unitech/pm2)

Dev   : [![Build Status](https://img.shields.io/travis/Unitech/pm2/development.svg?style=flat-square)](https://travis-ci.org/Unitech/pm2)

PM2'yi üretim sunucunuzda kullanmadan önce testleri denemeniz önemlidir:

```bash
git clone https://github.com/Unitech/pm2.git
cd pm2
npm install  # Eksik paketler varsa NODE_ENV=development npm install yapın
npm test
```

:::warning
Bir test düzgün çalışmazsa, lütfen [burada](https://github.com/Unitech/pm2/issues?state=open) sorunları bildirin. Ayrıca gereken tüm bağımlılıkların bulunduğundan emin olun.
:::

Ubuntu için:

```bash
sudo apt-get install build-essential
# nvm, Node.js sürüm yöneticisidir - https://github.com/creationix/nvm
wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh
nvm install 4
nvm use 4
```

---

## Dağıtım Sistemi

PM2, üretim ortamında uygulamaları sağlama ve güncelleme imkanı sunan basit ama güçlü bir dağıtım sistemine sahiptir. Bu, uygulamaları baremetal bir sunucuda tek seferde veya birden fazla sunucuda dağıtmak istediğinizde harika bir çözümdür.

```bash
> pm2 deploy <configuration_file> <environment> <command>

  Komutlar:
    setup                uzaktan kurulum komutlarını çalıştır
    update               dağıtımı en son sürüme güncelle
    revert [n]          [n]inci son dağıtıma veya 1'e geri dön
    curr[ent]           mevcut sürüm komitini çıkart
    prev[ious]          önceki sürüm komitini çıkart
    exec|run <cmd>      belirtilen <cmd>'yi çalıştır
    list                önceki dağıtım komitlerini listele
    [ref]               [ref]'ye dağıt, "ref" ayarı veya son etiket
```

Temelde tek yapmanız gereken, ecosystem.json dosyasına bir "deploy" niteliği eklemektir. İşte bir uygulamayı dağıtmak için gereken en az bir örnek:

Dağıtım sistemini yapılandırmak için, Uygulama Yapılandırma Dosyasına bir `deploy` niteliği ekleyin:

```javascript
module.exports = {
  apps : [{
    script: 'api.js',
  }, {
    script: 'worker.js'
  }],
   
  // Dağıtım Yapılandırması
  deploy : {
    production : {
       "user" : "ubuntu",
       "host" : ["192.168.0.13", "192.168.0.14", "192.168.0.15"],
       "ref"  : "origin/master",
       "repo" : "git@github.com:Username/repository.git",
       "path" : "/var/www/my-repository",
       "post-deploy" : "npm install"
    }
  }
};
```

:::note
**Not**: uygulama yapılandırma dosyasının yerel klasördeki adı ecosystem.config.js veya pm2.config.js olduğundan emin olun, böylece her komut için yapılandırma dosya adını yazmanıza gerek kalmaz.
:::

### Uzaktan Sunucuları Sağlama

Uzaktan sunucuları sağlamadan önce şunları doğrulayın:

- Uzaktan sunucularda PM2 yüklü
- Uzaktan sunucularda hedef deposunu GIT clone etmek için izin verilmiş

Uzaktan sunucular yapılandırıldığında, sağlama işlemine başlayabilirsiniz:

```bash
$ pm2 deploy production setup
```

:::note
**Not**: uygulama yapılandırma dosyası yerel klasörde ecosystem.config.js veya pm2.config.js adını taşıdığından, her seferinde dosya adını belirtmenize gerek yoktur.
:::

### Uygulamayı Dağıtma

Uzaktan sunucu sağlandıktan sonra, uygulamayı dağıtabilirsiniz:

```bash
$ pm2 deploy production
```

:::warning
**Not**: eğer git, yerel değişikliklerin olduğunu ama yine de uzak GIT üzerindekileri göndermek istiyorsanız, dağıtımı zorlamak için `--force` seçeneğini kullanabilirsiniz.
:::

### Önceki Dağıtıma Geri Dönme

Önceki dağıtıma geri dönmeniz gerekiyorsa, `revert` seçeneğini kullanabilirsiniz:

```bash
# -1 dağıtımına geri dön
$ pm2 deploy production revert 1
```

### Her Sunucuda Bir Komut Çalıştırma

Tek seferlik bir komutu çalıştırmak için `exec` seçeneğini kullanabilirsiniz:

```bash
$ pm2 deploy production exec "pm2 reload all"
```

### Özellikler

#### Dağıtım Yaşam Döngüsü

PM2 ile dağıtım yaparken, ne yapacağınızı ayarlama ve güncelleme işlemlerinden önce/sonra belirtebilirsiniz:

```
"pre-setup" : "echo 'kurulum süreci başlamadan önce ana bilgisayarda çalıştırılacak komutlar veya yerel betik yolu'",
"post-setup": "echo 'depo kopyalandıktan sonra ana bilgisayarda çalıştırılacak komutlar veya bir betik yolu'",
"pre-deploy" : "pm2 startOrRestart ecosystem.json --env production",
"post-deploy" : "pm2 startOrRestart ecosystem.json --env production",
"pre-deploy-local" : "echo 'Bu yerel olarak yürütülen bir komuttur'"
```

#### Çoklu Sunucu Dağıtımı

Aynı anda birden fazla sunucuya dağıtım yapmak için, `host` niteliği altında her bir sunucuyu bir dizi olarak tanımlamalısınız.

```
"host" : ["212.83.163.1", "212.83.163.2", "212.83.163.3"],
```

#### SSH Anahtarlarını Belirleme

`key` niteliğini, genel anahtarın yoluyla ekleyerek yukarıda belirtilen örneği kullanmalısınız:

```javascript
    "production" : {
      "key"  : "/path/to/some.pem", // kimlik doğrulamak için genel anahtarın yolu
      "user" : "node",              // kimlik doğrulamak için kullanılan kullanıcı
      "host" : "212.83.163.1",      // bağlanılacak yer
      "ref"  : "origin/master",
      "repo" : "git@github.com:repo.git",
      "path" : "/var/www/production",
      "post-deploy" : "pm2 startOrRestart ecosystem.json --env production"
    },
```

### Sorun Giderme

#### SSH Kopyalama Hataları

Çoğu durumda, bu hatalar `pm2`'nin deponuzu kopyalamak için gerekli anahtarlara sahip olmamasından kaynaklanacaktır. Her aşamada anahtarların mevcut olduğunu doğrulamanız gerekir.

__Adım 1__
Anahtarlarınızın doğru bir şekilde çalıştığından eminseniz, hedef sunucuda `git clone your_repo.git` komutunu çalıştırmayı deneyin. Başarılı olursa, bir sonraki adımlara geçin. Başarısız olursa, anahtarlarınızın hem sunucuda hem de git hesabınızda bulunduğundan emin olun.

__Adım 2__
Varsayılan olarak, `ssh-copy-id` varsayılan kimliği kopyalar, genellikle `id_rsa` olarak adlandırılır. Eğer bu uygun anahtar değilse:

```bash
ssh-copy-id -i path/to/my/key your_username@server.com
```
Bu, genel anahtarınızı `~/.ssh/authorized_keys` dosyasına ekler.

__Adım 3__
Aşağıdaki hatayı alırsanız:
```
--> Üretim ortamına dağıtım yapılıyor
--> ana bilgisayar mysite.com
  ○ ön ayak kancası
  ○ kurulumu çalıştırıyor
  ○ git@github.com:user/repo.git'yi klonluyor
'/var/www/app/source' dizinine klonlanıyor...
İzin reddedildi (publickey).
fatal: Uzak depodan okunamadı.

Lütfen doğru erişim haklarına sahip olduğunuzdan ve deponun var olduğundan emin olun.

**Klonlama başarısız oldu**

Dağıtım başarısız oldu
```
...bağlantı kurduğunuz her bir deponuz için doğru SSH anahtarlarının kullanıldığından emin olmanızı sağlayan bir ssh yapılandırma dosyası oluşturmayı düşünebilirsiniz. Bu, klonlamak istediğiniz herhangi bir depo için doğru SSH anahtarlarının kullanılmasını sağlamak için kesin bir yoldur. [bu örneğe](https://gist.github.com/Protosac/c3fb459b1a942f161f23556f61a67d66) bakın:

```
# ~/.ssh/config
Host alias
    HostName myserver.com
    User username
    IdentityFile ~/.ssh/mykey
# Kullanım: `ssh alias`
# Alternatif: `ssh -i ~/.ssh/mykey username@myserver.com`

Host dağıtım
    HostName github.com
    User username
    IdentityFile ~/.ssh/github_rsa
# Kullanım:
# git@deployment:username/anyrepo.git
# Bu, o IdentityFile'ı kullanan herhangi bir deponun kopyalanması içindir. Bu, uzak kopyalama komutlarınızın uygun anahtarı kullandığından emin olmak için iyi bir yoldur.
```


![](../images/cikti/pm2-hive.github.io/images/docker_logo.png)


## Docker Entegrasyonu

Konteynerleri mi kullanıyorsunuz? Size yardım ediyoruz. Üretim ortamında Node.js'i en üst düzeye çıkarmak için mükemmel bir yoldaş olan **pm2-runtime** ile bugün başlayın.

pm2-runtime'ın amacı, uygulamalarınızı uygun bir Node.js üretim ortamına sarım yapmaktır. Bu, Node.js uygulamalarının bir konteyner içinde çalıştırılmasında karşılaşılan ana sorunları çözer:

- Yüksek Uygulama Güvenilirliği için İkinci Süreç Yedekleme
- Süreç Akışı Kontrolü
- Her zaman sağlıklı ve yüksek performanslı kalmasını sağlamak için Otomatik Uygulama İzleme
- Otomatik Kaynak Haritası Bulma ve Çözümleme Desteği

Bundan daha fazlası, PM2'yi konteyner ile uygulama arasında bir katman olarak kullanmak, Node.js uygulamanızı üretim ortamında yönetmek için PM2'nin uygulama beyan dosyası (/docs/usage/application-declaration/) gibi güçlü özelliklerini, özelleştirilebilir günlük sistemini (/docs/usage/log-management/) ve diğer harika özellikleri getirir.

---

## PM2'yi Konteynerler İçinde Kullanma

Dockerfile'ınıza PM2'yi kurmak için bu satırı ekleyin:

```
RUN npm install pm2 -g
```

Sonra `node` ikili dosyasını `pm2-runtime` ile değiştirin 

```
CMD ["node", "app.js"]
```

şuna:

```
CMD ["pm2-runtime", "app.js"]
```

**Artık her şey hazır!** Node.js uygulamanız artık uygun bir Node.js üretim ortamına sarılmış durumda.

### Konfigürasyon Dosyası Başlatma

PM2 ile ham Node.js uygulamanızı çalıştırmak yerine, bir konfigürasyon dosyasında (veya işlem dosyasında) tanımlayıp, küme modunu etkinleştirmek gibi bazı yapılandırma değişkenleri ayarlayabilirsiniz.

Aşağıdaki içeriğe sahip bir ecosystem.config.js dosyası oluşturalım:

```javascript
module.exports = [{
  script: 'app.js',
  name: 'app',
  exec_mode: 'cluster',
  instances: 2
}, {
  script: 'worker.js',
  name: 'worker'
}]
```

Mevcut tüm seçenekler `burada` listelenmiştir.

Daha sonra **CMD** direktifini bununla değiştirebilirsiniz:

```
CMD ["pm2-runtime", "process.yml"]
```

Her süreci kendi Docker'ında ayırmak için --only [app-name] seçeneğini kullanabilirsiniz:

```
CMD ["pm2-runtime", "process.yml", "--only", "APP"]
```

### exec_mode kümesini nuxtjs ile birlikte kullanma

PM2'yi küme modunda çalıştırırken, `ecosystem.config.js` cwd yolunuza eklenecektir çünkü nuxtjs kök dizinini nasıl çözümlediğine bağlıdır; bunu düzeltmek için args bölümünde config yolunu belirtmeniz gerekir:

```javascript
module.exports = {
  apps: [
    {
      name: 'my-nuxtjs-app',
      exec_mode: 'cluster',
      instances: 2,
      cwd: '/var/www',
      script: './node_modules/nuxt-start/bin/nuxt-start.js',
      args: '-c /var/www/nuxt.config.js'
    }
  ]
}
```

### Günlük Formatı Seçeneği

Günlük çıktı formatını değiştirmek istiyorsanız, bu seçeneklerden birini seçebilirsiniz:

- **--json**: günlükleri JSON formatında çıkartır (logstash)
- **--format**: günlükleri = stil formatında çıkartır
- **--raw**: günlükleri olduğu gibi çıkartır

Bu bayraklardan birini kullanmak için sadece pm2-runtime'a geçirin:

```
CMD ["pm2-runtime", "--json", "process.yml"]
```

### Nazik Kapatmayı Etkinleştirme

Konteyner bir kapatma sinyali aldığında, PM2 bu sinyali uygulamanıza ileterek tüm veritabanı bağlantılarını kapatmasına, tüm sorguların işlenmesini beklemesine veya başarılı bir nazik kapanıştan önce gereken diğer son işlemlerin tamamlanmasını sağlamaya olanak tanır.

Bir kapatma sinyalini yakalamak oldukça basittir. Node.js uygulamalarınıza bir dinleyici eklemeniz ve uygulamayı durdurmadan önce gereken her şeyi gerçekleştirmeniz gerekir:

```javascript
process.on('SIGINT', function() {
   db.stop(function(err) {
     process.exit(err ? 1 : 0);
   });
});
```

Varsayılan olarak PM2, nihai SIGKILL sinyalini göndermeden önce 1600 ms bekleyecektir. Bu gecikmeyi, uygulama yapılandırma dosyanızın içinde `kill_timeout` seçeneğini ayarlayarak değiştirebilirsiniz.

Uygulama durumu yönetimi hakkında daha fazlasını `burada` okuyabilirsiniz.

### Geliştirme Ortamı

Geliştiricilere geliştirme, test ve üretim arasında tutarlı bir ortam sağlamak için bir konteyner içinde program yapmalarını istemek isteyebilirsiniz.

**pm2-runtime**'ı **pm2-dev** ile değiştirmek, izleme ve yeniden başlatma özelliklerini etkinleştirecektir. Bu, ev sahibi dosyaların konteynere VOLUME olarak açık olduğu bir geliştirme konteyneri için oldukça ilginçtir.

---

### PM2.io Kullanma

[Keymetrics.io](https://keymetrics.io/) , uygulamaları kolayca izleyip yönetmeyi sağlayan PM2 tabanlı bir izleme servisidir (günlükler, yeniden başlatma, istisna izleme...). Keymetrics üzerinde bir Bucket oluşturduğunuzda, bir kamu ve bir gizli anahtar alacaksınız.

**pm2-runtime** ile Keymetrics izlemesini etkinleştirmek için, ya CLI seçeneği **--public XXX** ve **--secret YYY**'yi kullanabilir ya da ortam değişkenleri **KEYMETRICS_PUBLIC** ve **KEYMETRICS_SECRET**'ı geçirebilirsiniz.

Dockerfile üzerinden CLI seçenekleriyle örnek:

```
CMD ["pm2-runtime", "--public", "XXX", "--secret", "YYY", "process.yml"]
```

Veya ortam değişkenleri aracılığıyla:

```
ENV PM2_PUBLIC_KEY=XXX
ENV PM2_SECRET_KEY=YYY
```

Veya Docker çalışma komutu aracılığıyla:

```
docker run --net host -e "PM2_PUBLIC_KEY=XXX" -e "PM2_SECRET_KEY=XXX" <...>
```

---

## pm2-runtime Yardımcı Programı

İşte pm2-runtime yardımcı programı:

```
>>> pm2-runtime -h

  Kullanım: pm2-runtime app.js

  pm2-runtime, bazı ilginç üretim özellikleri ile değiştirilebilir bir node.js ikilisidir.

  Seçenekler:

    -V, --version              versiyon numarasını çıkart
    -i --instances <number>    otomatik olarak [number] işlem başlatın, yük dengelemesi sağlayın. Genel performansı ve performans kararlılığını artırın.
    --secret [key]             [İZLEME] keymetrics gizli anahtarı
    --public [key]             [İZLEME] keymetrics genel anahtarı
    --machine-name [name]      [İZLEME] keymetrics makine adı
    --raw                      ham günlük çıktı
    --json                     günlükleri json formatında çıkart
    --format                   günlükleri key=val formatında çıkart
    --delay <seconds>          yapılandırma dosyasının başlangıcını <seconds> geciktirin
    --web [port]               işlem web API'sını [port]'da başlatın (varsayılan 9615)
    --only <application-name>  yalnızca yapılandırmanın bir uygulamasına işlem uygula
    --no-auto-exit             tüm işlemler hatalı/durmuş olduğunda veya 0 uygulama başlatıldığında çıkış yapmayın
    --env [name]               süreç konfigürasyon dosyasında env_[name] ortam değişkenlerini ekleyin
    --watch                    dosya değişikliğinde uygulamayı izleyin ve yeniden başlatın
    --error <path>             hata günlük dosyasının hedefi (varsayılan devre dışı)
    --output <path>            çıkış günlük dosyasının hedefi (varsayılan devre dışı)
    -h, --help                 kullanım bilgilerini çıkart

  Komutlar:

    *
    start <app.js|json_file>  bir uygulamayı veya json ekosistem dosyasını başlat
```

---

## Yeni Bir Süreç Başlatırken

PM2, **yeni bir süreç başlatırken** ortamı bu sırayla enjekte eder:

- İlk olarak PM2 CLI kendi ortamını kullanır, böylece shell'inizin mevcut ortamı enjekte edilir.
- PM2, ekosistem dosyası ile yapılandırılabilecek olan ortamı enjekte eder:

```javascript
module.exports = {
  apps : [
      {
        name: "myapp",
        script: "./app.js",
        watch: true,
        env: {
          "NODE_ENV": "development",
        }
      }
  ]
}
```

:::note
Burada PM2'nin mevcut ortamı `NODE_ENV=development` ekleyerek geçersiz kıldığını görebilirsiniz. Ancak şu şekilde farklı ortamlara da tanım ekleyebilirsiniz:
```javascript
module.exports = {
  apps : [
      {
        name: "myapp",
        script: "./app.js",
        watch: true,
        env: {
            "PORT": 3000,
            "NODE_ENV": "development"
        },
        env_production: {
            "PORT": 80,
            "NODE_ENV": "production",
        }
      }
  ]
}
```
Burada varsayılan ortam `env`'de, ancak `pm2 start ecosystem.config.js --env production` ile `env_production` kullanmayı seçebilirsiniz.

Dilediğiniz kadar ortam tanımlayabilirsiniz, sadece kullanmak istediğiniz ortamın adını (env_ sonrasında) `--env` ile geçirmeniz gerektiğini unutmayın.
:::

---

## Belirli Ortam Değişkenleri

### NODE_APP_INSTANCE (PM2 2.5 minimum)

Süreçler arasında ayrım yapmak için kullanılan `NODE_APP_INSTANCE` ortam değişkeni vardır, örneğin yalnızca bir süreçte bir görev çizelgesi çalıştırmak isteyebilirsiniz, sadece `process.env.NODE_APP_INSTANCE === '0'` kontrol edebilirsiniz. İki süreç asla aynı numaraya sahip olamaz, bu da `pm2 restart` ve `pm2 scale` komutları sonrasında halen geçerlidir.

:::danger
`NODE_APP_INSTANCE` adıyla [node-config](https://github.com/Unitech/pm2/issues/2045) ile bazı sorunlar yaşayabilirsiniz, bu nedenle `instance_var` seçenekleri ile yeniden adlandırabilirsiniz:
```javascript
module.exports = {
  apps : [
      {
        name: "myapp",
        script: "./app.js",
        watch: true,
        instance_var: 'INSTANCE_ID',
        env: {
            "PORT": 3000,
            "NODE_ENV": "development"
        }
      }
  ]
}
```
Bu durumda değişken aynı davranışa sahip olacak ancak `process.env.INSTANCE_ID` içinde bulunacaktır.
:::

#### increment_var (PM2 2.5 minimum)

Her biri başlatılan örnekler için bir ortam değişkeninin artmasını istemek için PM2'ye talimat verebilirsiniz, örneğin:

```javascript
module.exports = {
  apps : [
      {
        name: "myapp",
        script: "./app.js",
        instances: 2,
        exec_mode: "cluster",
        watch: true,
        increment_var : 'PORT',
        env: {
            "PORT": 3000,
            "NODE_ENV": "development"
        }
      }
  ]
}
```

Bu örnekte, `pm2 start ecosystem.config.js` komutunu çalıştırdığımda:
 - PM2, her bir örnek için `PORT` değişkenini artırmak istediğimi görecektir
 - Varsayılanın `3000` olduğunu görecektir
 - İlk örnek `process.env.PORT = 3000` ve ikinci `process.env.PORT = 3001` olacaktır

:::note
**NOT**: `pm2 scale myapp 4` kullanırken de artırma gerçekleşecektir, her iki yeni örnek de `3002` ve `3003` olarak `PORT` değişkenine sahip olacaktır.
:::

---

Eğer sadece Node.js'i ayarlamadan PM2'yi temiz bir kurulum olarak isterseniz, pm2 bir `.deb` paketi olarak mevcuttur!

En son Uzun Süreli Destek sürümüyle çalışacak şekilde inşa edilmiştir.

## Kurulum

```bash
# 1. PM2 Deposu imza anahtarını ekleyin
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv D1EA2D4C

# 2. PM2 deposunu ekleyin
echo "deb http://apt.pm2.io/ubuntu stable main" | sudo tee /etc/apt/sources.list.d/pm2.list

# 3. Mevcut paketlerin listesini güncelleyin
sudo apt-get update

# 4. PM2'yi kurun
sudo apt-get install pm2
```

---

## Uygulama Günlükleri

Bir uygulama PM2 ile başlatıldığında, günlükleri kolayca gözden geçirip yönetebilirsiniz.

Günlük dosyaları `$HOME/.pm2/logs` klasöründe bulunur.

---
description: PM2 ile uygulama günlüklerini görüntüleme ve yönetme yöntemlerini keşfedin. Bu içerik, günlük dosyalarını analiz etmek ve kontrol etmek için kullanılabilecek komutlar ve araçlar hakkında bilgi verir.
keywords: [PM2, günlük, komut, uygulama, yönetim]
---

### Log Görüntüleme

Uygulamanın günlüğünü görüntülemek için `pm2 logs` komutunu kullanabilirsiniz.

```bash
-l --log [path]              hem çıktı hem de hata günlüklerini çıkarmak için dosya yolunu belirtin
-o --output <path>           çıktı günlük dosyasını belirtin
-e --error <path>            hata günlük dosyasını belirtin

--time                       günlükleri standart formatta zaman damgasıyla ön ekle
--log-date-format <format>   günlükleri özel formatta zaman damgasıyla ön ekle
--log-type <type>            günlük çıktı stilini belirtin (varsayılan olarak raw veya json)
--merge-logs                 aynı uygulama adıyla birden fazla işlem çalıştırırken dosyayı kimliğine göre ayırmayın
```

Kullanım: logs [seçenekler] [id|ad|ad alanı]

günlük dosyalarını akışa al. Varsayılan olarak tüm günlükleri yayınlar.

#### Seçenekler:

```bash
    --json                json günlük çıktısı
    --format              biçimlendirilmiş günlük çıktısı
    --raw                 ham çıktı
    --err                 yalnızca hata çıktısını gösterir
    --out                 yalnızca standart çıktıyı gösterir
    --lines <n>           en son N satırını çıkar, varsayılan olarak son 15 yerine
    --timestamp [format]  zaman damgaları ekle (varsayılan format YYYY-MM-DD-HH:mm:ss)
    --nostream            günlük akışını başlatmadan günlükleri yazdır
    --highlight [value]   belirtilen değeri vurgular
    -h, --help            kullanım bilgilerini çıktı
```

### Önemli bazı komutlar:

```bash
# Tüm uygulama günlüklerini gerçek zamanlı olarak görüntüle
pm2 logs

# Sadece `api` uygulaması günlüklerini görüntüle
pm2 logs api

# JSON formatında yeni günlükleri görüntüle
pm2 logs --json

# api günlük dosyasının 1000 satırını görüntüle
pm2 logs big-api --lines 1000
```

:::info
Ayrıca CLI paneli ile günlüklere göz atabilirsiniz:

```bash
pm2 logs --json
```
:::

Her uygulama için satırda bu meta veriler yazdırılacaktır:

```json
{
   "message": "echo\n",                     // teorik olarak `console.log` ile yazılan gerçek mesaj
   "timestamp": "2017-02-06T14:51:38.896Z", // mesajın zaman damgası, biçimlendirilebilir
   "type": "out",                           // günlüklerin türü, `err`, `out` veya `PM2` olabilir
   "process_id": 0,                         // PM2 tarafından kullanılan işlem kimliği
   "app_name": "one-echo"                   // uygulama adı
}
```

---

## Günlük boyut sınırı

[pm2-logrotate](https://github.com/keymetrics/pm2-logrotate) modülü, tüm günlük dosyalarını otomatik olarak döndürür ve sınırlı alan kullanarak disk üzerinde saklar.

Kurmak için:

```bash
pm2 install pm2-logrotate
```

pm2-logrotate hakkında daha fazla bilgi okumak için [buraya](https://github.com/pm2-hive/pm2-logrotate#configure) tıklayın.

---

## Günlükleri temizleme

Bu, PM2 tarafından yönetilen mevcut uygulama günlüklerini boşaltacaktır:

```bash
pm2 flush

pm2 flush <api> # <api> ile eşleşen ad/id için günlüğü temizle
```

---

## Uygulama günlük seçenekleri

Bir uygulama başlatırken birçok seçenek belirtebilirsiniz.

### CLI

`pm2 start app.js [SEÇENEKLER]` komutunu çalıştırırken CLI'ye bu seçeneklerden herhangi birini geçirebilirsiniz:

```bash
-l --log [path]              hem çıktı hem de hata günlüklerini çıkarmak için dosya yolunu belirtin
-o --output <path>           çıktı günlük dosyasını belirtin
-e --error <path>            hata günlük dosyasını belirtin
--time                       günlükleri standart formatta zaman damgasıyla ön ekle
--log-date-format <format>   günlükleri özel formatta zaman damgasıyla ön ekle
--merge-logs                 aynı uygulama adıyla birden fazla işlem çalıştırırken dosyayı kimliğine göre ayırmayın
```

### Yapılandırma dosyası

Yapılandırma dosyası aracılığıyla seçenekleri geçirebilirsiniz:

|    Alan |   Tür  |  Örnek |  Açıklama|
|:----------|:-------:|:------------------------------:|:-------------------------|
|error_file| (dize)| | hata dosyası yolu (varsayılan olarak $HOME/.pm2/logs/&lt;uygulama adı&gt;-hata-&lt;pid&gt;.log)|
|out_file| (dize) | | çıktı dosyası yolu (varsayılan olarak $HOME/.pm2/logs/&lt;uygulama adı&gt;-çıktı-&lt;pid&gt;.log)|
|log_file| (dize) | | hem çıktı hem de hata günlükleri için dosya yolu (varsayılan olarak kapalı)|
|pid_file| (dize) | | pid dosyası yolu (varsayılan olarak $HOME/.pm2/pids/&lt;uygulama adı&gt;-&lt;pid&gt;.pid)|
|merge_logs| boolean | true | true olarak ayarlanırsa, günlük dosyalarını işlem kimliğiyle uzatmayı önleyin |
|log_date_format| (dize) | "YYYY-MM-DD HH:mm Z" | günlüğün tarih formatı (günlük bölümüne bakınız)|

### Günlük uzantısını devre dışı bırakma 

Küme modunda (node.js) uygulamalar için yalnızca;
Tüm küme süreçlerinin günlüklerini aynı dosyaya yazdırmasını istiyorsanız `--merge-logs` veya `merge_logs: true` seçeneğini kullanabilirsiniz.

### Günlüğü devre dışı bırakma

Tüm günlüklerin diske yazılmasını devre dışı bırakmak için `out_file` ve `error_file` seçeneklerini `/dev/null` olarak ayarlayabilirsiniz.

```js
module.exports = {
  apps : [{
    name: 'Business News Watcher',
    script: 'app.js',
    instances: 1,
    out_file: "/dev/null",
    error_file: "/dev/null"
    cron_restart: '0 0 * * *'
    [...]
  }]
}
```

Günlüklerin çıktısı için `/dev/null` veya `NULL` sağlayabilirsiniz (platformdan bağımsızdır, bunlar sabit bir dizedir).

### Yerel günlük döngüsü ayarlama

```bash
sudo pm2 logrotate -u user
```

Bu, `/etc/logrotate.d/pm2-user` konumuna temel bir günlük döngüsü yapılandırması yazacaktır:

```
/home/user/.pm2/pm2.log /home/user/.pm2/logs/*.log {
        rotate 12
        weekly
        missingok
        notifempty
        compress
        delaycompress
        create 0640 user user
}
```

---

## Max Bellek Eşiği Otomatik Yeniden Yükleme

PM2, bir uygulamayı bir bellek sınırına dayalı olarak yeniden yüklemeyi (kümle modunda değilse yenileme ile otomatik geri dönme) sağlar. PM2 iç işçisi (belleği kontrol eden), her 30 saniyede bir başlar, bu nedenle bellek eşiğine ulaştıktan sonra işleminiz otomatik olarak yeniden başlatılana kadar biraz beklemek zorunda kalabilirsiniz.

CLI:

```bash
pm2 start api.js --max-memory-restart 300M
```

Yapılandırma dosyası (ecosystem.config.js):

```bash
module.exports = {
  apps: [{
    name: 'api',
    script: 'api.js',
    max_memory_restart: '300M'
  }]
}
```

:::note
**Not:** Birimler K(ilobyte), M(egabyte), G(igabyte) olabilir.
:::

---

## CPU/Bellek İzleme


![](/images/pm2-monit.png "PM2 Monit"/>


PM2, uygulamanızın kaynak kullanımını izlemek için basit bir yol sunar.
Bellek ve CPU'yu kolaylıkla terminal aracılığıyla izleyebilirsiniz:

```bash
pm2 monit
```

---

## PM2.io

Node.js uygulamanızı PM2 ile yönetiyorsanız, [PM2.io](https://pm2.io) denemenizi öneririz. Bu, sunucular arasındaki uygulamaları izlemeyi ve yönetmeyi daha önce hiç olmadığı kadar kolaylaştırıyor.

Denemekten çekinmeyin:
[PM2 için izleme panelini keşfedin](https://app.pm2.io/#/register)

---

## PM2 API

PM2, süreçleri kod aracılığıyla doğrudan yönetmenizi sağlayan programlı olarak kullanılabilir.

## Hızlı Başlangıç

**Not**: PM2 ile bağlantıyı serbest bırakmak ve uygulamanızın otomatik olarak çıkmasını sağlamak için `pm2.disconnect()` ile PM2'den ayrıldığınızdan emin olun.

Öncelikle PM2'yi bağımlılık olarak ekleyin:

```bash
npm install pm2 --save
```

Sonrasında app.js ve pm2-control.js adında bir betik oluşturun ve şu kodları ekleyin:

```javascript
const pm2 = require('pm2')

pm2.connect(function(err) {
  if (err) {
    console.error(err)
    process.exit(2)
  }

  pm2.start({
    script    : 'api.js',
    name      : 'api'
  }, function(err, apps) {
    if (err) {
      console.error(err)
      return pm2.disconnect()
    }

    pm2.list((err, list) => {
      console.log(err, list)

      pm2.restart('api', (err, proc) => {
        // PM2'den bağlantıyı kes
        pm2.disconnect()
      })
    })
  })
})
```
- Bu yerel PM2'yi başlatacak veya ona bağlanacak
- Sonrasında app.js'yi **api** adıyla başlatacak
- PM2 ile yönetilen tüm uygulamaları görüntüleyecek
- Ardından **api** adıyla uygulamayı yeniden başlatacak
- Ve PM2'den bağlantıyı kesecek

---

### API Yöntemleri

#### pm2.connect([no_daemon_mode], fn)

Yerel PM2'ye bağlanın veya yeni bir PM2 örneği başlatın.

|    Param |   Tür  | Varsayılan |   Açıklama|
|:----------|:-------:|:---------:|:------------------|
|[no_daemon_mode]    | boolean   | false | true ise, bağımsız bir PM2 çalıştıracak ve bitiminde otomatik çıkacaktır|
|fn    | function   | | Geri çağırma|

* noDaemonMode: Eğer ilk argüman için true geçilirse, pm2 bir daemon olarak çalışmayacak ve ilgili betik çıktığında ölecek. Varsayılan olarak, pm2 betiğiniz çıktığında hayatta kalır. Eğer pm2 zaten çalışıyorsa, betiğiniz mevcut daemon'a bağlanacak ama süreciniz çıktığında ölecektir.

#### pm2.disconnect()

Yerel PM2'den bağlantıyı kesin.

#### pm2.start(process, fn)

Bir süreci başlat.

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|process    | string/object   | betik yolu (göreceli) veya `options` aracılığıyla nesne |
|fn    | function   | Geri çağırma|

#### pm2.stop(process, fn)

Bir süreci durdur.

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|process    | string/number   | hedef işlem kimliği veya adı|
|fn    | function   | Geri çağırma|

#### pm2.restart(process, [options], fn)

Bir süreci yeniden başlat.

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|process    | string/number   | hedef işlem kimliği veya adı|
|[options]  | object | `options` (güncellemenin zorlanması için updateEnv: true ekleyin)|
|fn    | function   | Geri çağırma|

#### pm2.reload(process, fn)

Bir süreci yeniden yükle.

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|process    | string/number   | hedef işlem kimliği veya adı|
|fn    | function   | Geri çağırma|

#### pm2.delete(process, fn)

Bir süreci sil.

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|process    | string/number   | hedef işlem kimliği veya adı|
|fn    | function   | Geri çağırma|

#### pm2.killDaemon(fn)

pm2 daemon'ını öldürür (aynı zamanda **pm2 kill**). Daemon öldüğünde, tüm süreçleri de öldürülecektir. Ayrıca, yine de daemon'u öldürseniz bile daemon'dan açıkça bağlantıyı kesmeniz gerektiğini unutmayın.

#### pm2.describe(process, fn)

**`pm2.connect(errback)`** - Çalışan bir pm2 daemon ("God")'a bağlanır veya başlatır ve daemonize eder. Başlatıldıktan sonra, pm2 süreci betik çıktığında çalışmaya devam edecektir.  
**`pm2.connect(noDaemonMode, errback)`**

* `noDaemonMode` - (Varsayılan: false) Eğer ilk argüman için true geçilirse, pm2 bir daemon olarak çalışmayacak ve ilgili betik çıktığında ölecek. Varsayılan olarak, pm2 betiğiniz çıktığında hayatta kalır. Eğer pm2 zaten çalışıyorsa, betiğiniz mevcut daemon'a bağlanacak ama süreciniz çıktığında ölecektir.
* `errback(error)` - pm2 daemon süreciyle bağlantı kurulduğunda veya başlatıldığında çağrılan geri çağırma.

**`pm2.start(options, errback)`** - pm2 tarafından yönetilecek bir betiği başlatır.  
**`pm2.start(jsonConfigFile, errback)`**  
**`pm2.start(script, errback)`**  
**`pm2.start(script, options, errback)`**  
**`pm2.start(script, jsonConfigFile, errback)`**  

* `script` - Çalıştırılacak betiğin yolu.
* `jsonConfigFile` - `options` parametresiyle aynı seçenekleri içerebilecek bir JSON dosyasının yolu.
* `errback(err,proc)` - `script` başlatıldığında çağrılan bir geri çağırma. `proc` parametresi bir [pm2 süreç nesnesi](https://github.com/soyuka/pm2-notify#templating) olacaktır.
* `options` - Aşağıdaki seçenekleri içeren bir nesne (bu seçeneklerin ek açıklamaları [burada](http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/#graceful-reload)):
  * `name` - İşlemle etkileşimde (örneğin yeniden başlatma) kullanılabilecek bir ad. Varsayılan olarak, uzantısı olmayan betik adıyla (örneğin `"testScript"` için `"testScript.js"`) gelir.
  * `script` - Çalıştırılacak betiğin yolu.
  * `args` - Betiğe geçirilecek argümanlardan oluşan bir dize veya dize dizisi.
  * `interpreterArgs` - Yorumlayıcı süreçle birlikte çağırmak için argümanlardan oluşan bir dize veya dize dizisi. Örneğin "--harmony" veya ["--harmony", "--debug"]. Yalnızca `interpreter` "none" dışında bir şeyse (varsayılan olarak "node"dur) geçerlidir.
  * `cwd` - Sürecin başlatılacağı çalışma dizini.
  * `output` - (Varsayılan: `"~/.pm2/logs/app_name-out.log"`) stdout çıktısının eklenmesi için bir dosyanın yolu. `error` ile aynı dosya olabilir.
  * `error` - (Varsayılan: `"~/.pm2/logs/app_name-error.err"`) stderr çıktısının eklenmesi için bir dosyanın yolu. `output` ile aynı dosya olabilir.
  * `logDateFormat` - Günlük zaman damgalarının görüntü formatı (örneğin "YYYY-MM-DD HH:mm Z"). Format, bir [moment görüntü formatı](http://momentjs.com/docs/#/displaying/)dır.
  * `pid` - (Varsayılan: `"~/.pm2/pids/app_name-id.pid"`) Başlatılan sürecin pid'sini yazmak için bir dosyanın yolu. Dosya üzerine yazılacak. Dosyanın pm2 tarafından hiçbir şekilde kullanılmadığını ve kullanıcıların bu dosyayı istedikleri zaman manipüle edebileceklerini veya kaldırabileceklerini unutmayın. Dosya, süreç durdurulduğunda veya daemon öldürüldüğünde silinecektir.
  * `minUptime` - Betiğin başarılı bir şekilde başlatılması için gereken minimum çalışma süresi. 
  * `maxRestarts` - Bir betiğin `min_uptime` altında çıkması durumunda üst üste en fazla kaç kez yeniden başlatılacağı.
  * `maxMemoryRestart` - Ayarlanırsa ve `script`'in bellek kullanımı belirlenen miktarın üzerinde giderse, pm2 `script`'i yeniden başlatır. İnsan dostu takma adlar kullanır: kilobayt için 'K', megabayt için 'M', gigabayt için 'G', vb. Örneğin "150M".
  * `killTimeout` - (Varsayılan: `1600`) "stop" veya "restart" komutunun `SIGINT` sinyali göndererek süreci zorla öldürmeden önce bekleyeceği milisaniye sayısıdır. 
  * `restartDelay` - (Varsayılan: `0`) Sonuçlanan bir betiği yeniden başlatmadan önce bekleyeceği milisaniye sayısı.  
  * `interpreter` - (Varsayılan: `'node'`) Betiğin yorumlayıcısı (örneğin "python", "ruby", "bash", vb). "none" değeri, 'script'i bir ikili yürütülebilir olarak çalıştırır.
  * `execMode` - (Varsayılan: `'fork'`) 'cluster' olarak ayarlanırsa, kümelenmeyi (sürecin birden fazla örneğini çalıştırmayı) etkinleştirir. [Daha fazla bilgi için buraya bakın](http://pm2.keymetrics.io/docs/usage/cluster-mode/).
  * `instances` - (*Varsayılan: `1`*) `script`'in kaç örneğinin oluşturulacağı. Sadece 'cluster' olan `exec_mode` için geçerlidir.
  * `mergeLogs` - (Varsayılan: `false`) Eğer true olarak ayarlanırsa, tüm `script` örnekleri için günlük dosyalarını tek bir stderr günlüğü ve bir stdout günlüğü olarak birleştirir. Yalnızca 'cluster' modunda geçerlidir. Örneğin, pm2 ile başlatılan 4 'test.js' örneğiniz varsa, normalde 4 stdout günlük dosyası ve 4 stderr günlük dosyanız olurdu, ancak bu seçenek true olarak ayarlandığında yalnızca bir stdout dosyanız ve bir stderr dosyanız olurdu.
  * `watch` - true olarak ayarlandığında, 'script' dosyası değiştiğinde uygulama yeniden başlatılacaktır.
  * `force` (Varsayılan: `false`). Varsayılan olarak, pm2 yalnızca bir betiği, o betik zaten çalışmadığı sürece başlatır (bir betik, bir uygulamanın yolu, zaten çalışan bir uygulamanın adı değildir). Eğer `force` true olarak ayarlanırsa, pm2 o betiğin yeni bir örneğini başlatacaktır.
  * `autorestart` (Varsayılan `true`). Eğer `false` ise, pm2 tamamlandıktan sonra veya süreç hatası durumunda yeniden başlatmaya çalışmayacaktır.
  * `cron`
  * `executeCommand`
  * `write`
  * `sourceMapSupport`
  * `disableSourceMapSupport`

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|process    | string/number   | hedef işlem kimliği veya adı|
|fn    | function   | Geri çağırma|

#### pm2.list(fn)

PM2 ile yönetilen tüm süreçleri alın.

---

### İleri Düzey Yöntemler

#### pm2.sendDataToProcessId(packet)

Hedef sürece veri gönderin.

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|packet.id    | number   | hedef işlem kimliği |
|packet.type    | string   | **process:msg** olmak zorundadır |
|packet.topic  | boolean | **true** olmak zorundadır |
|packet.data   | object | hedef sürece gönderilecek nesne verisi|

Veri, hedef süreçte şu şekilde alınacaktır:

```javascript
process.on('message', function(packet) {})
```

#### pm2.launchBus(fn)

Bu, PM2 ile yönetilen süreçlerden mesaj almayı sağlar.

```javascript
const pm2 = require('pm2')

pm2.launchBus(function(err, pm2_bus) {
  pm2_bus.on('process:msg', function(packet) {
    console.log(packet)
  })
})
```

Ardından, PM2 ile yönetilen bir süreçten:

```javascript
process.send({
  type : 'process:msg',
  data : {
    success : true
  }
})
```

#### pm2.sendSignalToProcessName(signal, process, fn)

Hedef süreç adına özel sistem sinyali gönderin.

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|signal    | string   | sistem sinyali adı  |
|process    | string   | hedef süreç adı |
|fn   | function | Geri çağırma(err, process) |

#### pm2.sendSignalToProcessId(signal, process, fn)

Hedef süreç kimliğine özel sistem sinyali gönderin.

|    Param |   Tür  |    Açıklama |
|----------|---------|----------------|
|signal    | string   | sistem sinyali adı  |
|process    | number   | hedef süreç kimliği |
|fn   | function | Geri çağırma(err, process) |

### Süreç yapısı

Yukarıda belirtilen herhangi bir yöntemi çağırdığınızda, değiştirilmiş bir süreç dizisi döndürülür. Bu nesne şunları içerir:

* **processDescription** - Süreç hakkında bilgi içeren nesnelerin dizisi. Her nesne şu özellikleri içerir:
  * **name** - Orijinal **start** komutunda verilen ad.
  * **pid** - Sürecin pid'si.
  * **pm_id** - **pm2** God daemon süreci için pid.
  * **monit** - Aşağıdaki bilgileri içeren bir nesne:
    * **memory** - Sürecin kullandığı byte sayısı.
    * **cpu** - Süreç tarafından o anda kullanılan CPU yüzdesi.
  * **pm2_env** - Sürecin ortamındaki yol değişkenlerinin listesi. Bu değişkenler şunları içerir:
    * **pm_cwd** - Sürecin çalışma dizini.
    * **pm_out_log_path** - stdout günlük dosyasının yolu.
    * **pm_err_log_path** - stderr günlük dosyasının yolu.
    * **exec_interpreter** - Kullanılan yorumlayıcı.
    * **pm_uptime** - Sürecin çalışma süresi.
    * **unstable_restarts** - Sürecin yaşadığı kararsız yeniden başlatmaların sayısı.
    * **restart_time**
    * **status** - "çevrimiçi", "durduruluyor", "durduruldu", "başlatılıyor", "hata", veya "birinci-aşama durumu"
    * **instances** - Çalışan örneklerin sayısı.
    * **pm_exec_path** - Bu süreçte çalıştırılan betiğin yolu.

---

### Örnekler

#### Sürece mesaj gönder

pm2-call.js:

```javascript
const pm2 = require('pm2')

pm2.connect(function() {
  pm2.sendDataToProcessId({
    // "pm2 list" komutundan veya pm2.list(errback) yönteminden işlem id'si
    id   : 1,

    // process:msg hedef süreçte 'message' olarak gönderilecektir
    type : 'process:msg',

    // Gönderilecek veri
    data : {
      some : 'data'
    },
    id   : 0, // "pm2 list" komutundan veya pm2.list(errback) yönteminden işlem id'si
    topic: 'some topic'
  }, function(err, res) {
  })
})

// Uygulamadan gelen mesajları dinleyin
pm2.launchBus(function(err, pm2_bus) {
  pm2_bus.on('process:msg', function(packet) {
    console.log(packet)
  })
})
```

pm2-app.js:

```javascript
process.on('message', function(packet) {
  process.send({
    type : 'process:msg',
    data : {
     success : true
    }
 });
});
```

PM2, bir uygulamayı başlatmanıza ve dosya değişikliklerinde yeniden başlatmanıza olanak tanıyan kullanışlı bir geliştirme aracıyla birlikte gelir:

```bash
# Uygulamanızı geliştirme modunda başlatın
# Günlükleri yazdırır ve dosya değiştiğinde yeniden başlatır

# Uygulamanızı çalıştırmanın iki yolu:
pm2-dev start my-app.js

# veya

pm2-dev my-app.js
```

---

## RPC Yöntemlerini Açığa Çıkarma: Süreç Eylemleri

RPC Yöntemlerini açığa çıkarmak, çalışan bir süreçle gerçek zamanlı olarak etkileşimde bulunmanıza olanak tanır.

Bu, aşağıdakiler için faydalıdır:
- Davranışı değiştirme (örn. günlüklemeyi hata ayıklama olarak değiştirmek)
- Veri yapısını alma
- Eylemleri tetikleme

### Hızlı Başlangıç

Öncelikle [tx2](https://github.com/pm2/tx2) modülünü kurun:

```bash
$ npm install tx2
```

Ardından, rpc.js adında bir uygulama oluşturun:

```javascript
const tx2 = require('tx2')

tx2.action('hello', (reply) => {
  reply({ answer : 'world' })
})

setInterval(function() {
  // Uygulamayı çevrimiçi tut
}, 100)
```

Ve bunu PM2 ile başlatın:

```bash
$ pm2 start rpc.js
```

Şimdi süreç eylemlerini tetiklemek için şu komutu kullanın:

```bash
$ pm2 trigger <uygulama-adı> <eylem-adı>
# pm2 trigger rpc hello
```

### Mevcut RPC Yöntemlerini Listeleme

Tüm mevcut RPC yöntemlerini listelemek için:

```bash
pm2 show <uygulama-adı>
# pm2 show rpc
```

---
title: Parametre Geçirme
description: Uzak bir fonksiyona parametre geçirme yöntemi ile ilgili açıklamalar ve örnekler. PM2 kullanarak uygulamanızı nasıl yeniden başlatacağınızı ve yönetebileceğinizi öğrenin.
keywords: [parametre geçirme, PM2, RPC, uygulama yönetimi, API]
---

### Parametre Geçirme

Uzak bir fonksiyona parametre geçirmek için, geri çağırmaya `param` niteliğini eklemeniz yeterlidir:

```javascript
var tx2 = require('tx2')
tx2.action('world', function(param, reply) {
  console.log(param)
  reply({success : param})
})
```

Uygulamanızı yeniden başlatın ve bu işlem fonksiyonunu PM2 ile çağırın:

```bash
pm2 trigger <uygulama-adı> <eylem-adı> [parametre]
# pm2 trigger rpc world somedata
```

### Web Gösterim Panelinden Tetikleme

:::info
Uygulamanızdan yayımlanan tüm RPC yöntemleri, [pm2.io](https://app.pm2.io) ile bağlantı kurulduğunda web arayüzünden görüntülenecek ve kullanılabilir hale gelecektir.
:::

## TX2 API Dokümantasyonu

[https://github.com/pm2/tx2/blob/main/API.md](https://github.com/pm2/tx2/blob/main/API.md)

---

## Uygulama Durumlarını Yönetme

PM2 ile arka planda uygulamaları başlatabilir/yeniden başlatabilir/yükleyebilir/durdurabilir/listeleyebilirsiniz.

### Başlatma

Bir uygulamayı başlatmak için:

```bash
$ pm2 start api.js
```

![image](https://user-images.githubusercontent.com/757747/123512784-b0341900-d689-11eb-93d4-69510ee2be27.png)

Her türlü uygulamayı, bash komutları, scriptler, ikili dosyalar gibi başlatabilirsiniz:

```bash
$ pm2 start "npm run start"
$ pm2 start "ls -la"
$ pm2 start app.py
```

#### Başlatma ve Log Akışını Gösterme

Bir uygulamayı başlatmak ve log akışını kontrol etmek için `--attach` seçeneğini kullanın:

```bash
$ pm2 start api.js --attach
```

Ctrl-C ile çıkış yaptığınızda, uygulama arka planda çalışmaya devam edecektir.

#### Argüman Geçirme

`--` sonrasında geçen tüm seçenekler uygulamaya argüman olarak geçirilecektir:

```bash
$ pm2 start api.js -- arg1 arg2
```

#### Konfigürasyon Dosyası

Birden fazla uygulamayı aynı anda yönetmek veya birden fazla seçeneği belirtmek için, bir konfigürasyon dosyası kullanabilirsiniz. Bu `ecosystem.config.js` dosyası ile bir örnek:

```javascript
module.exports = {
  apps : [{
    name   : "limit worker",
    script : "./worker.js",
    args   : "limit"
  },{
    name   : "rotate worker",
    script : "./worker.js",
    args   : "rotate"
  }]
}
```

Her iki uygulamayı başlatmak için:

```bash
$ pm2 start ecosystem.config.js
```

Daha fazla bilgi için `konfigürasyon dosyası` okuyun.

### Yeniden Başlatma

Bir uygulamayı yeniden başlatmak için:

```bash
$ pm2 restart api
```

Tüm uygulamaları yeniden başlatmak için:

```bash
$ pm2 restart all
```

#### Çevresel Değişkenler ve Seçenekleri Güncelleme

Çevresel değişkenleri veya PM2 seçeneklerini güncellemek için `--update-env` CLI seçeneğini belirtin:

```bash
$ NODE_ENV=production pm2 restart web-interface --update-env
```

### Durdurma

Belirtilen bir uygulamayı durdurmak için:

```bash
$ pm2 stop api
$ pm2 stop [işlem_id]
```

Hepsini durdurmak için:

```bash
$ pm2 stop all
```

> Not: bu, PM2 uygulama listesinden uygulamayı silmez. Bir uygulamayı silmek için bir sonraki bölüme bakın.

### Silme

Bir uygulamayı durdurmak ve silmek için:

```bash
$ pm2 delete api
```

Hepsini silmek için:

```bash
$ pm2 delete all
```

## Uygulamaları Listeleme

Tüm çalışan uygulamaları listelemek için:

```bash
$ pm2 list
# veya
$ pm2 [list|ls|l|status]
```

![image](https://user-images.githubusercontent.com/757747/123511260-a3f78e00-d680-11eb-8907-3f1017ef7dc8.png)

Uygulamanın hangi sırada listeleneceğini belirtmek için:

```bash
$ pm2 list --sort name:desc
# veya
$ pm2 list --sort [name|id|pid|memory|cpu|status|uptime][:asc|desc]
```

### Terminal Gösterim Paneli

PM2, uygulamanızın kaynak kullanımını izlemek için basit bir yol sunar. Bellek ve CPU'yu kolayca terminalinizden izleyebilirsiniz:

```bash
pm2 monit
```


<img src="../images/cikti/pm2-hive.github.io/images/pm2-monit.png" title="PM2 Monit"/>


### Uygulama Metadata Gösterimi

Bir uygulama hakkında metadata görüntülemek için:

```bash
$ pm2 show api
```

<img src="https://user-images.githubusercontent.com/757747/123510635-fafb6400-d67c-11eb-8534-0ce6106979b2.png" alt="çizim" width="600"/>

### Yeniden Başlatma Sayacını Sıfırlama

Yeniden başlatma sayacını sıfırlamak için:

```bash
$ pm2 reset all
```

---

## Ölçüleri Açığa Çıkarma

Kendi özel ölçülerinizi kodunuza entegre ederek, kod içi değerleri gerçek zamanlı olarak izleyebilirsiniz.

### Hızlı Başlangıç

Öncelikle [tx2](https://github.com/pm2/tx2) modülünü yükleyin:

```bash
$ npm install tx2
```

Sonra `monit.js` adında bir uygulama oluşturun:

```javascript
const tx2 = require('tx2')
const http = require('http')

let meter = tx2.meter({
  name      : 'req/sec',
  samples   : 1,
  timeframe : 60
})

http.createServer((req, res) => {
  meter.mark()
  res.writeHead(200, {'Content-Type': 'text/plain'})
  res.write('Merhaba Dünya!')
  res.end()
}).listen(6001)
```

Ve PM2 ile başlatın:

```bash
$ pm2 start monit.js
```

Artık metrikleri şu komutla gösterin:

```bash
$ pm2 show [uygulama]
# pm2 show monit
```

*Not*: Metrikler "Özel Metrikler" bölümündedir.

<img src="../images/cikti/pm2-hive.github.io/images/processmetrics.png" title="özel metrikler" width="600"/>

veya Terminal tabanlı arayüzü kullanabilirsiniz:

```bash
$ pm2 monit
```

<img src="https://i.imgur.com/WHDEvHg.png" title="özel metrikler" width="300"/>

## Metrik yardımcı mevcuttur

Kendi önemli bilgilerinizi izlemek için kendi metriklerinizi programlayabilirsiniz. 4 farklı ölçüm türü mevcuttur:

- **Basit metrikler**: Anında okunabilen değerler
  - Örnek: Değişken değerini izleme
- **Sayaç**: Artan veya azalan şeyler
  - Örnek: İşlenen indirmeler, bağlı kullanıcılar
- **Metre**: Olaylar/ara ile ölçülen şeyler
  - Örnek: HTTP sunucusu için dakikada istek
- **Histogram**: İstatistiksel olarak ilgili değerlerin havuzunu tutar ve son 5 dakikaya yönelik dağılımlarını keşfeder
  - Örnek: Bir sorgunun veri tabanındaki yürütme ortalamasını izlemek

### API Dokümantasyonu

**Not**: [TX2 API Dokümantasyonu'na](https://github.com/pm2/tx2/blob/main/API.md) başvurun.

### Örnekler

#### Basit Metrik: Basit değer raporlama

Bu, hemen okunabilen değerleri açığa çıkarmanızı sağlar.

```javascript
const tx2 = require('tx2')

// Burada değer fonksiyonu her saniyede bir çağrılacak
var metric = tx2.metric({
  name    : 'Aktif kullanıcı',
  value   : function() {
    return Object.keys(users).length
  }
})

// Burada valvar.set() fonksiyonunu çağırarak yeni değeri ayarlayacağız
var valvar = tx2.metric({
  name    : 'Gerçek Zamanlı Değer'
})

valvar.set(23)
```

#### Sayaç: Sıralı değer değişimi

Artan veya azalan değerler.

Aktif HTTP İsteklerini saymak için bir örnek:

```javascript
const tx2 = require('tx2')
var http = require('http')

var counter = tx2.counter({
  name : 'Aktif istekler'
})

http.createServer(function (req, res) {
  counter.inc()

  req.on('end', function() {
    // Sayaçtan bir azalt, sayaç 0 olacak
    counter.dec()
  })
  res.writeHead(200, {'Content-Type': 'text/plain'})
  res.write('Merhaba Dünya!')
  res.end()
}).listen(6001)
```

#### Metre: Ortalama hesaplanan değerler

Olaylar/ara ile ölçülen değerler.

Dakikada kaç sorgu sayılacağını örneklemek için:

```javascript
const tx2 = require('tx2')
var http = require('http')

var meter = tx2.meter({
  name      : 'req/sec',
  samples   : 1,
  timeframe : 60
})

http.createServer(function (req, res) {
  meter.mark()
  res.writeHead(200, {'Content-Type': 'text/plain'})
  res.write('Merhaba Dünya!')
  res.end()
}).listen(6001)
```

##### Seçenekler

**samples** seçeneği oran birimidir. Varsayılan olarak **1** saniyedir.  
**timeframe** seçeneği, olayların analiz edileceği zaman dilimidir. Varsayılan olarak **60** saniyedir.

#### Histogram

Son 5 dakikaya yönelik dağılımları araştırmak için istatistiksel olarak ilgili değerlerin havuzunu tutar.

```javascript
const tx2 = require('tx2')

var histogram = tx2.histogram({
  name        : 'gecikme',
  measurement : 'ortalama'
})

var latency = 0

setInterval(function() {
  latency = Math.round(Math.random() * 100)
  histogram.update(latency)
}, 100)
```

---

## Yeniden Başlatma Stratejileri

PM2 ile uygulama başlatıldığında, uygulama otomatik çıkışta, olay döngüsü boş olduğunda (node.js) veya uygulama çökünce otomatik olarak yeniden başlatılır.  
Ancak ayrıca ekstra yeniden başlatma stratejileri de yapılandırabilirsiniz:

PM2 Runtime'da yeni bir yeniden başlatma modu uygulanmıştır, uygulamanızın yeniden başlatmalarını daha akıllı bir şekilde gerçekleştirmektedir. Örneğin, veritabanı kapalı olduğunda uygulamanızı çılgınca yeniden başlatmak yerine, *eksponansiyel gerileme yeniden başlatma* zamanı, yeniden başlatmalar arasındaki süreyi aşamalı olarak artırarak veritabanı veya harici sağlayıcı üzerindeki baskıyı azaltacaktır... Kullanımı oldukça kolay:

```bash
$ pm2 start app.js --cron-restart="0 0 * * *"
# veya bir uygulamayı yeniden başlatırken
$ pm2 restart app --cron-restart="0 0 * * *"
```

Konfigürasyon dosyası aracılığıyla, `cron_restart` niteliğini kullanın:

```javascript
module.exports = {
  apps : [{
    name: 'İş Haberleri İzleyici',
    script: 'app.js',
    instances: 1,
    cron_restart: '0 0 * * *',
    env: {
      NODE_ENV: 'geliştirme'
    },
    env_production: {
      NODE_ENV: 'üretim'
    }
  }]
}
```

---

## Dosya Değişikliğinde Yeniden Başlatma

PM2, mevcut dizinde veya alt dizinlerinde bir dosya değiştirildiğinde otomatik olarak uygulamanızı yeniden başlatabilir:

CLI ile:

```bash
$ pm2 start app.js --watch
```

*Not*: `--watch` seçeneği ile başlatılan bir uygulama durdurulursa, dosya değişiminde yeniden başlatılmasını engellemez. Tamamen izleme özelliğini devre dışı bırakmak için: `pm2 stop app --watch` veya uygulamanın yeniden başlatılmasında izleme seçeneğini değiştirebilirsiniz: `pm2 restart app --watch`.

Konfigürasyon dosyası ile, `watch: true` niteliğini kullanın:

```javascript
module.exports = {
  script: "app.js",
  watch: true
}
```

Değişim için hangi klasörü izleyeceğinizi, görmezden gelinecek klasörleri ve izleme dosya aralığını şu seçeneklerle belirtebilirsiniz:

```javascript
module.exports = {
  script: "app.js",
  // İzlenecek klasörü belirtin
  watch: ["server", "client"],
  // İzleme aralığı arasındaki gecikmeyi belirtin
  watch_delay: 1000,
  // Görmezden gelinecek klasörü belirtin 
  ignore_watch : ["node_modules", "client/img"],
}
```

---

## Bellek Tabanlı Yeniden Başlatma Stratejisi

PM2, bir bellek sınırına dayalı olarak bir uygulamayı yeniden başlatabilir (kümle dışında yeniden başlatmaya otomatik olarak geçiş yapar). Lütfen PM2 iç işçisinin (belleği kontrol eder) her 30 saniyede bir çalıştığını ve bellek eşik noktası aşıldığında uygulamanızın otomatik olarak yeniden başlatılabilmesi için biraz beklemeniz gerekebileceğini unutmayın.

CLI:

```bash
$ pm2 start api.js --max-memory-restart 300M
```

Konfigürasyon dosyasıyla, `max_memory_restart` niteliğini kullanın:

```javascript
module.exports = {
  script: 'api.js',
  max_memory_restart: '300M'
}
```

> Not: Birimler K(ilobayt) (örneğin `512K`), M(egabayt) (örneğin `128M`), G(igabayt) (örneğin `1G`) olabilir.

### Yeniden Başlatma Gecikmesi

Yeniden başlatma Gecikmesi stratejisi ile otomatik yeniden başlatmalar arasında bir gecikme ayarlayın:

CLI:

```bash
$ pm2 start app.js --restart-delay=3000
```

Konfigürasyon dosyasıyla, `restart_delay` niteliğini kullanın:

```javascript
module.exports = {
  script: 'app.js',
  restart_delay: 3000
}
```

### Otomatik Yeniden Başlatmayı Devre Dışı Bırakma

Bu, bir seferlik betikleri çalıştırmak istediğimizde ve işlemi yöneticisinin betiğimizin tamamlandığında yeniden başlatmasını istemediğimizde yararlıdır.

CLI:

```bash
$ pm2 start app.js --no-autorestart
```

Konfigürasyon dosyasıyla, `autorestart` niteliğini kullanın:

```javascript
module.exports = {
  script: 'app.js',
  autorestart: false
}
```

### Belirli Çıkış Kodu İçin Otomatik Yeniden Başlatmayı Atla

Bazı durumlarda, uygulamanın başarısızlığı durumunda otomatik yeniden başlatılmasını (yani sıfırdan farklı bir çıkış kodu) istemek isteyebilirsiniz,  
Aynı zamanda uygulamanız düzgün bir şekilde kapandığında da (yani çıkış kodu sıfır eşit olduğunda) işlem yöneticisinin yeniden başlatmamasını sağlamalısınız.

Bu durumda, PM2'yi `stop_exit_codes` seçeneği ile otomatik yeniden başlatmayı atlayacak şekilde kullanmaya devam edebilirsiniz:

CLI:

```bash
$ pm2 start app.js --stop-exit-codes 0
```

Veya konfigürasyon dosyasıyla, `stop_exit_codes` niteliğini kullanın:

```javascript
module.exports = [{
  script: 'app.js',
  stop_exit_codes: [0]
}]
```

### Eksponansiyel Geri Dönüş Yeniden Başlatma Gecikmesi

PM2 Runtime'da yeni bir yeniden başlatma modu uygulanmıştır, uygulamanızın yeniden başlatmalarını daha akıllı bir şekilde gerçekleştirmektedir. Örneğin, veritabanı kapalı olduğunda uygulamanızı çılgınca yeniden başlatmak yerine, *eksponansiyel geri dönüş yeniden başlatma* zamanı, yeniden başlatmalar arasındaki süreyi aşamalı olarak artırarak veritabanı veya harici sağlayıcı üzerindeki baskıyı azaltacaktır... Kullanımı oldukça kolay:

CLI:

```bash
$ pm2 start app.js --exp-backoff-restart-delay=100
```

Konfigürasyon dosyasıyla, `exp_backoff_restart_delay` niteliğini kullanın:

```javascript
module.exports = {
  script: 'app.js',
  exp_backoff_restart_delay: 100
}
```

Uygulama beklenmedik bir şekilde çöktüğünde ve `--exp-backoff-restart-delay` seçeneği etkinleştirildiğinde, yeni bir uygulama durumu **yeniden başlatmayı bekliyor** olarak gözlemlenecektir.

`pm2 logs` komutunu çalıştırdığınızda, yeniden başlatma gecikmesinin artırıldığını göreceksiniz:

```
PM2      | App [throw:0] will restart in 100ms
PM2      | App [throw:0] exited with code [1] via signal [SIGINT]
PM2      | App [throw:0] will restart in 150ms
PM2      | App [throw:0] exited with code [1] via signal [SIGINT]
PM2      | App [throw:0] will restart in 225ms
```

Görüldüğü gibi, yeniden başlatmalar arasındaki gecikme, maksimum 15000 ms'ye ulaşana kadar, eksponansiyel hareketli ortalama ile artmaktadır.

Uygulama daha sonra kararlı bir duruma (30 saniyeden fazla yeniden başlatmasız çalışma) geri döndüğünde, yeniden başlatma gecikmesi otomatik olarak 0 ms'ye sıfırlanacaktır.

---

## HTTP Üzerinden Statik Dosya Sunma

PM2, `pm2 serve` özelliğini kullanarak statik dosyaları çok kolay bir şekilde sunabilir.  
Belirtilen bir klasörden ham dosyaları sunmayı ya da tek sayfa uygulaması (SPA) sunmayı destekler.

## CLI

Statik dosyalarınızı (örneğin bir ön yüz uygulaması) HTTP üzerinden basit bir komutla sunun:

```bash
pm2 serve <path> <port>
```

Eğer `` belirtmezseniz geçerli klasör kullanılacaktır, port için varsayılan port `8080`'dir.  
Normal uygulamalar için aynı seçenekleri kullanabilirsiniz, örneğin `--name` veya `--watch`.

## Süreç Dosyası

Bir süreç dosyasında özel bir dizin sunmak istediğinizi belirtebilirsiniz, bunu yapmak için:

```javascript
module.exports = {
  script: "serve",
  env: {
    PM2_SERVE_PATH: '.',
    PM2_SERVE_PORT: 8080
  }
}
```

Yalnızca yolu ve portu belirtmek için `PM2_SERVE_PATH` ve `PM2_SERVE_PORT` çevre değişkenlerini eklemeniz gerekir, varsayılan değerler CLI ile aynıdır.

## SPA Sunma: Tüm İstekleri index.html'ye Yönlendirme

Tüm sorguları otomatik olarak `index.html`'ye yönlendirmek için `--spa` seçeneğini kullanın:

```bash
pm2 serve --spa
```

Bir süreç dosyası yoluyla:

```javascript
module.exports = {
  script: "serve",
  env: {
    PM2_SERVE_PATH: '.',
    PM2_SERVE_PORT: 8080,
    PM2_SERVE_SPA: 'true',
    PM2_SERVE_HOMEPAGE: './index.html'
  }
}
```

### Erişimi Şifre ile Koruma

Açık dosyalara erişimi temel şifre korumayla korumak için `--basic-auth-username` ve `--basic-auth-password` seçeneklerini kullanabilirsiniz:

```bash
pm2 serve --basic-auth-username <kullanıcı_adı> --basic-auth-password <şifre>
```

Bir süreç dosyası yoluyla:

```javascript
module.exports = {
  script: "serve",
  env: {
    PM2_SERVE_PATH: '.',
    PM2_SERVE_PORT: 8080,
    PM2_SERVE_BASIC_AUTH: 'true',
    PM2_SERVE_BASIC_AUTH_USERNAME: 'örnek-giriş',
    PM2_SERVE_BASIC_AUTH_PASSWORD: 'örnek-şifre'
  }
}
```

---

## CLI Tamamlama

PM2 için sekme tamamlama:

```bash
pm2 completion install
```

Veya tamamlama komutunu manuel olarak ~/.bashrc veya ~/.zshrc dosyanıza ekleyin:

```bash
pm2 completion >> ~/.bashrc # veya ~/.zshrc
```

Sonra mevcut oturum için .bashrc veya .zshrc dosyanızı kaynaklayın:

```bash
source ~/.bashrc # veya ~/.zshrc
```

Şu şekilde PM2 tamamlama işlevini mevcut oturumunuza ekleyebilirsiniz:

```bash
. <(pm2 completion)
```

---

## Nazik Durdurma

Nazik yeniden başlatma/yükleme/durdurma işlemleri için, işlem sinyalini yakalayıp ihtiyacınız olan her şeyi (veritabanı bağlantıları, işleme işleri vb.) temizlediğinizden emin olun:

```javascript
process.on('SIGINT', function() {
   db.stop(function(err) {
     process.exit(err ? 1 : 0)
   })
})
```

Artık `pm2 reload` nazik yeniden yükleme haline gelecektir.

### öldürme zaman aşımını yapılandırma

CLI aracılığıyla, zaman aşımını 3000 ms'ye uzatın:

```bash
pm2 start app.js --kill-timeout 3000
```

[Uygulama beyanı](http://pm2.keymetrics.io/docs/usage/application-declaration/) aracılığıyla `kill_timeout` niteliğini kullanın:

```javascript
module.exports = {
  apps : [{
    name: 'app',
    script: './app.js',
    kill_timeout : 3000
  }]
}
```

---

## Nazik Başlatma

Bazen, uygulamanızın veritabanlarınız/önbellekleriniz/işleyicileriniz/neyse onunla bağlantı kurmasını beklemeniz gerekebilir. PM2, uygulamanızı çevrimiçi olarak kabul etmeden önce bekleyecektir. Bunu yapmak için, CLI'ye `--wait-ready` vermeniz veya bir süreç dosyasında `wait_ready: true` belirtmeniz gerekir. Bu, PM2'nin o olayı dinlemesini sağlar. Uygulamanızda, uygulamanızın hazır olarak kabul edilmesini istediğinizde `process.send('ready');` eklemeniz gerekir.

```javascript
var http = require('http')

var app = http.createServer(function(req, res) {
  res.writeHead(200)
  res.end('merhaba')
})

var listener = app.listen(0, function() {
  console.log('Port ' + listener.address().port üzerinde dinleniyor')
  // Burada PM2'ye hazır sinyalini gönderiyoruz
  process.send('ready')
})
```

Sonra uygulamayı başlatın:

```bash
pm2 start app.js --wait-ready
```

### Hazır zaman aşımını ayarlama

Varsayılan olarak, PM2 `ready` sinyali için 3000 ms bekler.

CLI aracılığıyla, bu zaman aşımını 10000 ms'ye uzatın:

```bash
pm2 start app.js --wait-ready --listen-timeout 10000
```

`Uygulama beyanı` aracılığıyla `listen_timeout` ve `wait_ready` niteliğini kullanın:

```javascript
module.exports = {
  apps : [{
    name: 'app',
    script: './app.js',
    wait_ready: true,
    listen_timeout: 10000
  }]
}
```

### HTTP.Sunucu.dinlemek için nazik başlatma

Hala `http.Server.listen` yöntemine entegre olan varsayılan sistem vardır. HTTP sunucunuz bir bağlantıyı kabul ettiğinde, uygulamanız otomatik olarak hazır olarak kabul edilir. PM2'nin dinleme süresine olan bekleme süresini artırabilirsiniz, bunu CLI'de `--wait-ready` nazik başlatma ile aynı değişkeni kullanarak yapabilirsiniz: süreç dosyasında `listen_timeout` girişi veya CLI aracılığıyla `--listen-timeout=XXXX`.

---

## Açıklama: Sinyal akışı

PM2 tarafından bir işlem durdurulduğunda/yeniden başlatıldığında, sistem sinyalleri belirli bir sırada işleminize iletilir.

Öncelikle bir **SIGINT** sinyali işlemlerinize gönderilir, bu sinyali durdurulacak işleminizi bilmek için yakalayabilirsiniz. Eğer uygulamanız 1.6 saniye içinde kendiliğinden çıkmazsa *([özelleştirilebilir](http://pm2.keymetrics.io/docs/usage/signals-clean-restart/#customize-exit-delay))* bir **SIGKILL** sinyali alarak zorla işlem çıkışı yapılır.

**SIGINT** sinyali, ortam değişkeni **PM2_KILL_SIGNAL** ayarlanarak herhangi bir başka sinyal ile de değiştirilebilir.

## Windows'ta nazik durdurma

Sinyaller mevcut değilken, işleminiz öldürülür. Bu durumda, CLI aracılığıyla `--shutdown-with-message` kullanmalı veya Ecosystem Dosyasında `shutdown_with_message` kullanmalı ve `shutdown` olaylarını dinlemelisiniz.

CLI aracılığıyla:

```bash
pm2 start app.js --shutdown-with-message
```

`Uygulama beyanı` aracılığıyla `listen_timeout` ve `wait_ready` niteliğini kullanın:

```javascript
module.exports = {
  apps : [{
    name: 'app',
    script: './app.js',
    shutdown_with_message: true
  }]
}
```

`shutdown` olaylarını dinleme

```javascript
process.on('message', function(msg) {
  if (msg == 'shutdown') {
    console.log('Tüm bağlantıları kapatıyorum...')
    setTimeout(function() {
      console.log('Bağlantıları kapatmayı bitirdim')
      process.exit(0)
    }, 1500)
  }
})
```

Eğer [BabelJS](https://babeljs.io/), [Typescript](http://www.typescriptlang.org/) veya herhangi bir başka Javascript üst kümesi kullanıyorsanız, istisna meydana geldiğinde hatanın anlamlı olmadığını fark etmiş olabilirsiniz. İlginç bilgiler elde etmek için [kaynak harita dosyaları](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/) oluşturmanız gerekir.

Bu kaynak harita dosyaları oluşturulduktan sonra, PM2 bunları otomatik olarak algılar ve hataları incelemenize yardımcı olur.

---
title: Kaynak Haritası
description: PM2'nin JavaScript kaynak haritası desteği ve uygulamanızı başlatma yöntemlerini açıklamaktadır. Ayrıca, PM2 ile port yönetimi ve başlangıç betiği oluşturma konularında da bilgi verilmektedir.
keywords: [PM2, kaynak haritası, uygulama başlatma, port yönetimi, başlangıç betiği, JavaScript, uzaktan izleme]
---

## Kaynak Haritası

1.0.2 sürümünden itibaren, PM2 javascript kaynak haritasını desteklemek için bir mekanizma entegre etmiştir.

**PM2, javascript kaynak harita dosyalarını otomatik olarak tespit eder** eğer app.js'i başlatırsanız, app.js.map dosyasının da mevcut olmasını bekler.

Farklı bir düzeniniz varsa, uygulamanızı başlatarak kaynak harita desteğini zorlayabilirsiniz:

:::tip
CLI üzerinden:
:::

```bash
pm2 start app.js --source-map-support
```

Veya JSON dosyası aracılığıyla:

```javascript
module.exports = {
   name: 'babel-app',
   script: 'app.js',
   source_map_support: true
}
```

### İstisnaları İnceleme

İstisnalar, uygulamanızın hata kayıt dosyasına kaydedilir.

İstisnaları tespit etmek için günlüklerinizi kontrol etmek isterseniz, şunları yazabilirsiniz:

```bash
pm2 logs main
```

Aksi takdirde, [keymetrics.io](https://keymetrics.io/) kullanarak temiz bir listeleme ve [yeni uyarılar](http://docs.keymetrics.io/docs/pages/issues/) için bildirimler alabilirsiniz.

### Kaynak Harita Desteğini Devre Dışı Bırakma

PM2'nin javascript kaynak haritalarını otomatik olarak desteklemesini istemiyorsanız `--disable-source-map-support` seçeneğini kullanabilirsiniz.

Bu, hem CLI üzerinden hem de JSON dosyası aracılığıyla desteklenmektedir.

---

## Kök Olmadan 80 Numaralı Portta Dinleme

Node'u kök olarak çalıştırmamanız gerektiği genel bir kuraldır. Ancak yalnızca kök, 1024'ten daha düşük portlara bağlanabilir. Burada authbind devreye girer. 

:::info
Authbind, kök olmayan kullanıcıların 1024'ten daha düşük portlara bağlanmasına olanak tanır. `%user%`'i `pm2`'yi çalıştıracak kullanıcıyla değiştirin.
:::

```bash
sudo apt-get install authbind
sudo touch /etc/authbind/byport/80
sudo chown %user% /etc/authbind/byport/80
sudo chmod 755 /etc/authbind/byport/80
```

Ayrıca, `pm2` profilini çalıştıran kullanıcıya bir takma ad eklemelisiniz, örneğin `~/.bashrc` veya `~/.zshrc` (not: hemen ardından `source ~/.bashrc` veya `source ~/.zshrc` komutunu çalıştırmanız gerekecek):

```diff
+alias pm2='authbind --deep pm2'
```

Son olarak, `pm2`'nin `authbind` ile güncellenmesini sağlayın:

```sh
authbind --deep pm2 update
```

Ya da takma adı kullanıyorsanız, sadece `pm2 update` çalıştırın.

> Artık, kök olmadan 80 numaralı porta bağlanabilen PM2 ile uygulamalar başlatabilirsiniz!

---

## Aynı Sunucuda Birden Fazla PM2

İstemci ve daemon, $HOME/.pm2/pub.sock ve $HOME/.pm2/rpc.sock dosyaları aracılığıyla iletişim kurarlar.

`PM2_HOME` ortam değişkenini değiştirerek birden fazla PM2 örneği başlatabilirsiniz.

```bash
PM2_HOME='.pm2' pm2 start echo.js --name="echo-node-1"
PM2_HOME='.pm3' pm2 start echo.js --name="echo-node-2"
```

Bu, iki farklı PM2 örneği başlatır. Farklı örnekler tarafından yönetilen süreçleri listelemek için:

```bash
PM2_HOME='.pm2' pm2 list
PM2_HOME='.pm3' pm2 list
```

---

## PM2'yi Daemonsuz Başlatma

PM2'yi daemonsuz modda başlatmadan önce, herhangi bir PM2 örneğini öldürdüğünüzden emin olun (`pm2 kill`).

PM2'yi kendi kendine daemonlaştırmadan başlatma:

```bash
pm2 start app.js --no-daemon
```

Varsayılan olarak PM2 kurulumu sırasında yüklenen CLI `pm2-runtime`, Node.js ikili dosyasının doğrudan bir yerine geçme işlevini görür.

---

## Durumsuz Uygulamalar

Üretim uygulamanızın **durumsuz** olması gerektiği genel bir kuraldır. Her veri, durum, websocket oturumu, oturum verisi, herhangi bir veritabanı veya PUB/SUB sistemi aracılığıyla paylaşılmalıdır.

:::danger
Aksi takdirde, uygulamanız aynı sunucuda ve birden fazla sunucu arasında ölçeklenmesi zor olacaktır.
:::

Örneğin, oturumları paylaşmak için [connect-redis](https://github.com/visionmedia/connect-redis) kullanabilirsiniz.

12 faktör kuralına uymanızı da öneririz: [http://12factor.net/](http://12factor.net/)

---

## Bir Sunucuda PM2'yi Kurma

[PM2'yi Kullanarak Node.js Üretim Ortamını Ubuntu VPS Üzerinde Kurma](https://www.digitalocean.com/community/articles/how-to-use-pm2-to-setup-a-node-js-production-environment-on-an-ubuntu-vps).

---

## Günlük ve PID Dosyaları

Varsayılan olarak, günlükler (hata ve çıktı), pid dosyaları, dökümler ve PM2 günlükleri `~/.pm2/` dizininde bulunur:

```
.pm2/
├── dump.pm2
├── custom_options.sh
├── pm2.log
├── pm2.pid
├── logs
└── pids
```

---

## Harmony ES6'yı Etkinleştirme

`--node-args` seçeneği, node yorumcusuna argüman eklenmesine olanak tanır. Bir süreç türü için harmony etkinleştirmek amacıyla aşağıdaki komutu girin:

```bash
pm2 start my_app.js --node-args="--harmony"
```

Bir JSON bildirimi içinde:

```json
[{
  "name" : "ES6",
  "script" : "es6.js",
  "node_args" : "--harmony"
}]
```

---

## CoffeeScript

### CoffeeScript v1

```bash
pm2 install coffee-script 
pm2 start app.coffee
```

### CoffeeScript v2

```bash
pm2 install coffeescript
pm2 start app.coffee
```

Hepsi bu kadar!

---

## JSON'ı Borulama

Pull-requests:
- [#273](https://github.com/Unitech/pm2/pull/273)
- [#279](https://github.com/Unitech/pm2/pull/279)

```bash
#!/bin/bash

read -d '' my_json <<_EOF_
[{
    "name"       : "app1",
    "script"     : "/home/projects/pm2_nodetest/app.js",
    "instances"  : "4",
    "error_file" : "./logz/child-err.log",
    "out_file"   : "./logz/child-out.log",
    "pid_file"   : "./logz/child.pid",
    "exec_mode"  : "cluster_mode",
    "port"       : 4200
}]
_EOF_

echo $my_json | pm2 start -
```

---

## Süreç Başlığı

PM2 ile bir uygulama başlatırken `PROCESS_FILE` ortam değişkenini belirleyebilirsiniz, bu değişken bir süreç başlığı ayarlayacaktır. Bu, süreçten belirli verileri almaya çalışırken oldukça faydalıdır, örneğin `ps -fC name` kullanabilirsiniz.

---

## Transpilerlar

PM2 ile [Transpiler Kullanma](http://pm2.keymetrics.io/docs/tutorials/using-transpilers-with-pm2) kılavuzuna bakın.

---

## Sorunlardan Kullanıcı İpuçları

- [Vagrant ve pm2 #289](https://github.com/Unitech/pm2/issues/289#issuecomment-42900019)
- [Aynı uygulamayı farklı portlarda başlatma #322](https://github.com/Unitech/pm2/issues/322#issuecomment-46792733)
- [pm2 ile ansible kullanma](https://github.com/Unitech/pm2/issues/88#issuecomment-49106686)
- [Argüman olarak crontab dizesi](https://github.com/Unitech/pm2/issues/496#issuecomment-49323861)
- [Süreç belirli bir bellek miktarına ulaştığında yeniden başlatma](https://github.com/Unitech/pm2/issues/141)
- [Sticky oturumlar ve socket.io tartışması](https://github.com/Unitech/PM2/issues/637)
- [EACCESS - pm2 kullanıcı/kök haklarını anlama](https://github.com/Unitech/PM2/issues/837)

---

## Dış Kaynaklar ve Makaleler

- [PM2 — Araç Genel Bakış ve Kurulum](https://futurestud.io/tutorials/pm2-utility-overview-installation)
- [Ubuntu 16.04 Üzerinde Üretim İçin Node.js Uygulaması Kurma](https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-16-04)
- [Eğitim: AWS'de Bir Node.js Sunucusu Oluşturma ve Yönetme, bölüm 2](https://hackernoon.com/tutorial-creating-and-managing-a-node-js-server-on-aws-part-2-5fbdea95f8a1)
- [Hoşçakal node-forever, merhaba pm2](http://devo.ps/blog/goodbye-node-forever-hello-pm2/)
- [https://www.howtoforge.com/tutorial/how-to-deploy-nodejs-applications-with-pm2-and-nginx-on-ubuntu/](https://www.howtoforge.com/tutorial/how-to-deploy-nodejs-applications-with-pm2-and-nginx-on-ubuntu/)
- [https://serversforhackers.com/editions/2014/11/04/pm2/](https://serversforhackers.com/editions/2014/11/04/pm2/)
- [http://www.allaboutghost.com/keep-ghost-running-with-pm2/](http://www.allaboutghost.com/keep-ghost-running-with-pm2/)
- http://blog.ponyfoo.com/2013/09/19/deploying-node-apps-to-aws-using-grunt
- http://www.allaboutghost.com/keep-ghost-running-with-pm2/
- http://bioselemental.com/keeping-ghost-alive-with-pm2/
- http://blog.chyld.net/installing-ghost-on-ubuntu-13-10-aws-ec2-instance-with-pm2/
- http://blog.marvinroger.fr/gerer-ses-applications-node-en-production-pm2/
- https://www.codersgrid.com/2013/06/29/pm2-process-manager-for-node-js/
- http://www.z-car.com/blog/programming/how-to-rotate-logs-using-pm2-process-manager-for-node-js
- http://yosoftware.com/blog/7-tips-for-a-node-js/
- https://www.exponential.io/blog/nodeday-2014-moving-a-large-developer-workforce-to-nodejs
- http://blog.rapsli.ch/posts/2013/2013-10-17-node-monitor-pm2.html
- https://coderwall.com/p/igdqyw
- http://revdancatt.com/2013/09/17/node-day-1-getting-the-server-installing-node-and-pm2/
- https://medium.com/tech-talk/e7c0b0e5ce3c

---

## Sürekli Uygulamalar: Başlangıç Betiği Üretici

PM2, beklenen veya beklenmeyen makine yeniden başlatmaları arasında süreç listenizi korumak için başlangıç betikleri oluşturabilir ve yapılandırabilir.

### Başlangıç Betiği Oluşturma

Otomatik olarak bir başlangıç betiği oluşturmak ve yapılandırmak için sadece (sudo olmadan) `pm2 startup` komutunu yazın:

```bash
$ pm2 startup
[PM2] Bu komutu kök olarak çalıştırmalısınız. Aşağıdaki komutu çalıştırın:
      sudo su -c "env PATH=$PATH:/home/unitech/.nvm/versions/node/v14.3/bin pm2 startup <distribution> -u <user> --hp <home-path>"
```

Sonra terminale gösterilen komutu kopyalayıp yapıştırın:

```bash
sudo su -c "env PATH=$PATH:/home/unitech/.nvm/versions/node/v14.3/bin pm2 startup <distribution> -u <user> --hp <home-path>"
```

Artık PM2 otomatik olarak önyükleme sırasında yeniden başlayacaktır.

**Not**: Servis adını `--service-name ` seçeneği aracılığıyla özelleştirebilirsiniz ([#3213](https://github.com/Unitech/pm2/pull/3213)).

### Uygulama Listesini Yeniden Başlatmak İçin Kaydetme

Tüm istenen uygulamaları başlattıktan sonra, listenizi kaydedin, böylece yeniden başlatıldığında tekrar canlandırsın:

```bash
pm2 save
```

### Süreçleri Manuel Olarak Yeniden Diriltme

Önceden kaydedilen süreçleri (pm2 save ile) manuel olarak geri getirmek için:

```bash
pm2 resurrect
```

### Başlangıç Sistemini Devre Dışı Bırakma

Mevcut başlangıç yapılandırmasını devre dışı bırakmak ve kaldırmak için:

```bash
pm2 unstartup
```

Önceki satır kodu PM2'nin platformunuzu algılamasına izin verir. Alternatif olarak, kendiniz başka bir belirtilen init sistemini kullanabilirsiniz:

#### Node.js sürümü güncellemesini takip etme

Yerel Node.js sürümünü yükselttiğinizde, PM2 başlangıç betiğini güncellediğinizden emin olun, böylece yüklediğiniz en son Node.js ikili dosyasını çalıştırır.

Önce mevcut başlangıç yapılandırmasını devre dışı bırakın ve kaldırın (o komutun çıktısını kopyalayıp yapıştırın):

```bash
$ pm2 unstartup
```

Sonra yeni bir başlangıç betiği geri yükleyin:

```bash
$ pm2 startup
```

#### Kullanıcı İzinleri

Başlangıç betiğinin başka bir kullanıcı altında çalıştırılmasını istiyorsanız.

Sadece `-u ` seçeneğini ve `--hp ` seçeneğini değiştirin:

```bash
pm2 startup ubuntu -u www --hp /home/ubuntu
```

#### Init Sistemini Belirtme

İstemci kendi platformunuzu belirtmek istiyorsanız, şu şekilde belirtebilirsiniz (platform ya yukarıdaki belirtilenlerden biri olabilir):

```
pm2 startup [ubuntu | ubuntu14 | ubuntu12 | centos | centos6 | arch | oracle | amazon | macos | darwin | freebsd | systemd | systemv | upstart | launchd | rcd | openrc]
```

#### SystemD Kurulumunu Kontrol Etme

```bash
# pm2-<USER> servisinin eklenip eklenmediğini kontrol edin
$ systemctl list-units
# Günlükleri kontrol et
$ journalctl -u pm2-<USER>
# systemd yapılandırma dosyasını okuyun
$ systemctl cat pm2-<USER>
# Başlangıcı analiz et
$ systemd-analyze plot > output.svg
```

PM2'nin çalışması için makinenin çevrimiçi durumunda beklemek:

```
[Unit]
Wants=network-online.target
After=network.target network-online.target

[....]

[Install]
WantedBy=multi-user.target network-online.target
```

#### Windows Başlangıç Betiği

Windows uyumlu bir başlangıç betiği oluşturmak için mükemmel [pm2-installer](https://github.com/jessety/pm2-installer) projesine göz atın.

#### Desteklenen Init Sistemleri

- **systemd**: Ubuntu >= 16, CentOS >= 7, Arch, Debian >= 7
- **upstart**: Ubuntu <= 14
- **launchd**: Darwin, MacOSx
- **openrc**: Gentoo Linux, Arch Linux
- **rcd**: FreeBSD
- **systemv**: Centos 6, Amazon Linux

Bu init sistemleri, `pm2 startup` komutu ile PM2 tarafından otomatik olarak algılanır.

---

## PM2'yi Güncelleme

PM2'yi güncellemek son derece hızlıdır (birkaç saniye içinde) ve sorunsuzdur.

### PM2'yi Güncelleme Süreci

En son PM2 sürümünü yükleyin:

```bash
npm install pm2 -g
```

Artık in-memory PM2 daemon'unu şu komutla güncelleyebilirsiniz:

```bash
pm2 update
```

### Node.js Sürümünü Yükseltme

Node.js yüklemenizi güncellediğinizde, PM2'yi başlatırken Node.js sürümünü de güncellediğinizden emin olun.

PM2 başlangıç betiğini güncellemek için:

```bash
$ pm2 unstartup
$ pm2 startup
```

---

## AWS Elastic Beanstalk'da PM2/Keymetrics Kullanma

Bu sayfa, PM2/Keymetrics entegrasyonunu Beanstalk ortamında adım adım size rehberlik edecektir. Daha kolay dağıtım için [eb cli](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html) kullanmanızı öneririz.

Kolay test için bir repository oluşturduk: [pm2-ebs-demo](https://github.com/keymetrics/pm2-ebs-demo).

---

## Beanstalk'ı Kurma

Uygulama dizininize gidin ve Beanstalk'ı yapılandırmak için `eb init` komutunu kullanın.

Beanstalk'ın uygulamanızı `npm start` kullanarak başlatmaya çalışacağından emin olmalıyız. Bunu yapmak için, kök dizininizde uygulamanızı başlatan komutu belirten bir Procfile dosyası ekleyin.

./Procfile

```
web: npm start
```

---

## PM2'yi Entegre Etme

PM2'yi uygulamanızı izlemek için en kolay ve en az müdahale gerektiren yol, bunu bir npm modülü olarak talep etmektir. Sadece `package.json` yapısını değiştirerek pm2'nin uygulamayı başlatmasına izin vereceğiz.

Sadece pm2'yi uygulama bağımlılıklarınız arasına ekleyin: 

```bash
npm install pm2 --save
```

Ardından başlangıç betiklerini değiştirmemiz gerekecek. PM2'yi node_modules klasöründen çağıracağız:

```json
"scripts": {
  "start": "./node_modules/pm2/bin/pm2-runtime app.js",
  "poststart":  "node ./node_modules/pm2/bin/pm2 logs"
}
```

 * `"start"` betiğini ihtiyaçlarınıza göre özelleştirin.
 * `"poststart"` betiği isteğe bağlıdır, ancak AWS panelinde doğrudan basit günlük kontrolüne izin verir.

Hepsi bu kadar! PM2 örneğini ElasticBeanstalk örneklerinizde minimum aşırılıkla almak için `eb deploy` komutunu çalıştırın.

---

## PM2'yi Keymetrics ile Entegre Etme

Keymetrics ile bağlantı kurmak için PM2'ye ortamdan iki değişken geçmemiz gerekiyor: `KEYMETRICS_PUBLIC` ve `KEYMETRICS_SECRET`.

* CLI'dan ortamı oluştururken:

```bash
eb create --envvars KEYMETRICS_PUBLIC=XXXXX,KEYMETRICS_SECRET=XXXXXX
```

* Bu değişkenleri AWS paneli yazılım yapılandırma seçeneklerine de ekleyebilirsiniz.

Ardından pm2 entegrasyon prosedürünü takip edin ve pm2 uygulamayı başlatırken otomatik olarak bağlayacaktır.

---

## Bulut Sağlayıcılarında PM2 Kullanma

Node.js uygulamalarınızı başlatmak için CLI'ye erişiminiz olmayan bir durumda kalabilirsiniz.

Böyle bir durumda, pm2 bağımlılık olarak eklenmeli ve başlangıç betiği ile çağrılmalıdır.

---

## Uygulamanızı Hazırlayın

### Ekosistem Dosyanızı Ayarlayın

Bir `ecosystem.config.js` şablonu oluşturmak için:

```bash
pm2 init
```

Ekosistem dosyasını ihtiyaçlarınıza uygun hale getirmek için düzenleyin:

```javascript
module.exports = {
  apps : [{
    name: "app",
    script: "./app.js",
    env: {
      NODE_ENV: "development",
    },
    env_production: {
      NODE_ENV: "production",
    }
  }]
}
```

Ekosistem dosyası hakkında daha fazla bilgi edinin `burada`.
{: .tip}

### PM2'yi Modül Olarak Ekleyin

PM2'yi projenize bağımlılık olarak ekleyin.

Npm ile:

```bash
npm install pm2
```

Yarn ile:

```bash
yarn add pm2
```

### package.json'daki Başlangıç Betiği

`package.json` dosyanızda `start` betiğinizi aşağıdaki gibi değiştirin:

```json
{
  "scripts": {
    "start": "pm2-runtime start ecosystem.config.js --env production"
  }
}
```

---

## Uygulamanızı Dağıtın

Artık uygulamanızı, normal bir node.js uygulaması için yaptığınız gibi bulut sağlayıcılarınıza dağıtabilirsiniz.

---

## Dosya Değiştiğinde Uygulamaları Otomatik Yeniden Başlatma

PM2, mevcut dizinde veya alt dizinlerinde bir dosya değiştirildiğinde uygulamanızı otomatik olarak yeniden başlatabilir:

```bash
pm2 start app.js --watch
```

Veya yapılandırma dosyası aracılığıyla `watch: true` seçeneğini ayarlayın.

Bir uygulama `--watch` seçeneği ile başlatıldığında, uygulamayı durdurmak dosya değiştiğinde yeniden başlatılmasını engellemeyecektir.

Tamamen izleme özelliğini devre dışı bırakmak için: `pm2 stop app --watch` veya uygulamayı yeniden başlatırken izleme seçeneğini değiştirmek için `pm2 restart app --watch` kullanın.

Belirli yolları izlemek için lütfen `Ecosystem Dosyası` kullanın, `watch` bir dize veya bir dizi yol alabilir. Varsayılan `true` değerine sahiptir:

```javascript
module.exports = {
  apps: [{
    script: "app.js",
    watch: ["server", "client"],
    // Yeniden başlatma gecikmesi
    watch_delay: 1000,
    ignore_watch : ["node_modules", "client/img"],
  }]
}
```  