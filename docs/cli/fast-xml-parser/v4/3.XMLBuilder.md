---
title: XML Builder
description: XML Builder, JavaScript nesnelerini XML formatına dönüştürmek için kullanılan bir araçtır. Bu içerik, XML Builder'ın çeşitli özelliklerini ve örneklerini detaylandırmaktadır.
keywords: [XML, JS nesnesi, fast-xml-parser, XMLBuilder, JSON]
---

XML Builder, bir JS nesnesini XML'e ayrıştırmak için kullanılabilir. Aşağıdaki seçenekleri destekler;

```js
const {XMLBuilder} = require('fast-xml-parser');

const options = {
    ignoreAttributes : false
};

const builder = new XMLBuilder(options);
let xmlDataStr = builder.build(jObj);
```

## arrayNodeName
Bir diziden XML oluşturduğunuzda, `arrayNodeName` seçeneğini bir isim olarak ayarlamak daha iyidir.

```js
const cars = [
    {
        "color": "purple",
        "type": "minivan",
        "registration": "2020-02-03",
        "capacity": 7
    },
    {
        "color": "orange",
        "type": "SUV",
        "registration": "2021-05-17",
        "capacity": 4
    },
];
const builder = new XMLBuilder({
    arrayNodeName: "car"
});
const output = builder.build(cars);
```

```xml
<car>
    <color>purple</color>
    <type>minivan</type>
    <registration>2020-02-03</registration>
    <capacity>7</capacity>
</car>
<car>
    <color>orange</color>
    <type>SUV</type>
    <registration>2021-05-17</registration>
    <capacity>4</capacity>
</car>
```

:::tip
`arrayNodeName` kullanarak, dizideki her bir nesne için özel bir etiket adı belirlemeniz önerilir.
:::

## attributeNamePrefix
JS nesnesindeki nitelik özelliklerini tanımak için kullanılır, böylece kesilebilirler.

## attributesGroupName
JS nesnesindeki nitelik özellikleri grubunu tanımak için kullanılır, böylece kesilebilirler ve bir etiket için nitelik ifadesi oluşturulabilir.

Bu özellik, `preserveOrder: true` ayarlandığında desteklenmez, çünkü nitelikler zaten gruplanmıştır.

## attributeValueProcessor
Bir nitelik değerinin dize değerine ayrıştırılma davranışını özelleştirmek için. Nitelik adı ve değeri kabul eder.

:::info
Nitelik işleme ile ilgili daha fazla bilgi almak için lütfen dökümantasyonu gözden geçirin.
:::

## cdataPropName
JS nesnesindeki CDATA özelliklerini tanımak için kullanılır, böylece doğru şekilde dönüştürülebilirler.

Örnek

Girdi
```json
{
    "any_name": {
        "person": {
            "phone": [
                122233344550,
                122233344551,
                ""
            ],
            "name":  [
                "<some>Jack</some>Jack",
                "<some>Mohan</some>"
            ],
            "blank": "",
            "regx":  "^[ ].*$"
        }
    }
};
```
Kod
```js
const options = {
    processEntities:false,
    format: true,
    ignoreAttributes: false,
    cdataPropName: "phone"
};

const builder = new XMLBuilder(options);
const xmlOutput = builder.build(input);
```

Çıktı
```xml
<any_name>
    <person>
        <![CDATA[122233344550]]>
        <![CDATA[122233344551]]>
        <![CDATA[]]>
        <name><some>Jack</some>Jack</name>
        <name><some>Mohan</some></name>
        <blank></blank>
        <regx>^[ ].*$</regx>
    </person>
</any_name>`;
```

XML'i JS nesnesine ayrıştırırken ve XML'i geri oluştururken `preserveOrder: true` kullanılması önerilir. Böylece CDATA'nın sırası korunur.
## commentPropName
JS nesnesindeki yorumları tanımak için kullanılır, böylece doğru şekilde dönüştürülebilirler.

Örnek

Girdi
```json
{
    "any_name": {
        "person": {
            "phone": [
                122233344550,
                122233344551,
                ""
            ],
            "name":  [
                "<some>Jack</some>Jack",
                "<some>Mohan</some>"
            ],
            "blank": "",
            "regx":  "^[ ].*$"
        }
    }
};
```
Kod
```js
const options = {
    processEntities:false,
    format: true,
    ignoreAttributes: false,
    commentPropName: "phone"
};

const builder = new XMLBuilder(options);
const xmlOutput = builder.build(input);
```

Çıktı
```xml
<any_name>
    <person>
        <!--122233344550-->
        <!--122233344551-->
        <!---->
        <name><some>Jack</some>Jack</name>
        <name><some>Mohan</some></name>
        <blank></blank>
        <regx>^[ ].*$</regx>
    </person>
</any_name>`;
```

XML'i JS nesnesine ayrıştırırken ve XML'i geri oluştururken `preserveOrder: true` kullanılması önerilir. Böylece yorumların sırası korunur.

## format
Varsayılan olarak, ayrıştırılan XML tek satır XML dizesidir. `format: true` ile, daha iyi görünüm için formatlayabilirsiniz.

## ignoreAttributes

Varsayılan olarak, `ignoreAttributes` seçeneği, XML oluşturulurken nitelikleri atlar. Ancak, belirli nitelikleri seçici bir şekilde atlamak için bir dize, düzenli ifade veya bir geri çağırma fonksiyonu dizisi belirtmek mümkündür.

### Seçici Nitelik Atlama

`ignoreAttributes` seçeneği şunları destekler:

1. **Dize Dizisi**: XML oluşturulurken belirli nitelikleri adlarıyla atlayın.
2. **Düzenli İfade Dizisi**: XML oluşturulurken bir desene uyan nitelikleri atlayın.
3. **Geri Çağırma Fonksiyonu**: XML oluşturma sürecinde özel mantığa göre nitelikleri atlayın.

### Örnek Girdi JSON

```json
{
    "tag": {
        "$ns:attr1": "a1-value",
        "$ns:attr2": "a2-value",
        "$ns2:attr3": "a3-value",
        "$ns2:attr4": "a4-value",
        "tag2": {
            "$ns:attr1": "a1-value",
            "$ns:attr2": "a2-value",
            "$ns2:attr3": "a3-value",
            "$ns2:attr4": "a4-value"
        }
    }
}
```

### Örnek: Dize Dizisi ile Nitelikleri Atlamak

```js
const options = {
    attributeNamePrefix: "$",
    ignoreAttributes: ['ns:attr1', 'ns:attr2']
};
const builder = new XMLBuilder(options);
const xmlOutput = builder.build(jsonData);
```

Sonuç:
```xml
<tag ns2:attr3="a3-value" ns2:attr4="a4-value">
    <tag2 ns2:attr3="a3-value" ns2:attr4="a4-value"></tag2>
</tag>
```

### Örnek: Düzenli İfadeler ile Nitelikleri Atlamak

```js
const options = {
    attributeNamePrefix: "$",
    ignoreAttributes: [/^ns2:/]
};
const builder = new XMLBuilder(options);
const xmlOutput = builder.build(jsonData);
```

Sonuç:
```xml
<tag ns:attr1="a1-value" ns:attr2="a2-value">
    <tag2 ns:attr1="a1-value" ns:attr2="a2-value"></tag2>
</tag>
```

### Örnek: Geri Çağırma Fonksiyonu ile Nitelikleri Atlamak

```js
const options = {
    attributeNamePrefix: "$",
    ignoreAttributes: (aName, jPath) => aName.startsWith('ns:') || jPath === 'tag.tag2'
};
const builder = new XMLBuilder(options);
const xmlOutput = builder.build(jsonData);
```

Sonuç:
```xml
<tag ns2:attr3="a3-value" ns2:attr4="a4-value">
    <tag2></tag2>
</tag>
```

## indentBy
Sadece `format:true` ayarı aktifse geçerlidir.

## preserveOrder
XMLParser'ı `preserveOrder: true` ile kullandığınızda, sonuç JS nesnesinin farklı bir yapısı olur. Bu yapıyı orijinal XML'e ayrıştırmak için, o js nesnesinden XML oluştururken aynı seçeneği ayarlamalısınız.

## processEntities
XML varlıklarını işlemek için `true` (varsayılan) olarak ayarlayın. Daha fazla ayrıntı için `Varlıklar` bölümüne bakın. XML belgenizde varlık yoksa, daha iyi performans için `processEntities: false` ayarlamanız önerilir.

## oneListGroup

Bu özellik, tüm alt etiketleri tek bir üst etiket altında toplar.

```json
{
    "Attributes": [
        {
            "Attribute": "1"
        },
        {
            "Attribute": "2"
        }
    ]
}
```
```js
const builder = new XMLBuilder({oneListGroup:"true"})
const output = builder.build(json)
```
Çıktı
```xml
<Attributes>
    <Attribute>1</Attribute>
    <Attribute>2</Attribute>
</Attributes>
```

## stopNodes
Herhangi bir etiketi ayrıştırmaktan ve işlem yapmaktan kaçınmak için XML ayrıştırıcı yapılandırmasına `stopNodes` ayarlandığında, bunu oluşturucuya da ayarlayabilirsiniz. Daha fazla ayrıntı için `HTML Belge Ayrıştırma` bölümüne bakın.

Bu özellik, şu anda yalnızca `preserveOrder: true` seçeneği ile desteklenmektedir.

## suppressBooleanAttributes
Değeri `true` olan nitelikleri, değerleri olmadan ayrıştırabilirsiniz.

Girdi
```js
const jsOrderedObj = [
    {
        "?textinfo": [
            {
                "#text": ""
            }
        ],
        ":@": {
            "@_whitespace": true,
            "@_is": true,
            "@_allowed": true
        }
    }
];
const options = {
    ignoreAttributes: false,
    preserveOrder: true,
    allowBooleanAttributes: true,
    suppressBooleanAttributes: true
};
const builder = new XMLBuilder(options);
const output = builder.build(result);
```
Çıktı
```xml
<?textinfo   whitespace is allowed?>
```

## suppressEmptyNode
Metin değerine sahip olmayan etiketler, boş etiket olarak ayrıştırılır.

Girdi
```js
const builder = new XMLBuilder({
    arrayNodeName: "any", //etkili değil
    suppressEmptyNode: true
});
const output = builder.build({
    a: 32,
    b: ""
});
```
Çıktı
```xml
<a>32</a>
<b/>
```

## suppressUnpairedNode

Eşleşmeyen bir etiketin `` ile `` arasında gizlenmesi için.

## tagValueProcessor
Etiketin metin değerinin dize değerine ayrıştırılma davranışını özelleştirmek için. Etiket adı ve değeri kabul eder.

## textNodeName
JS nesnesindeki bir etiket için metin değerini tanımak için kullanılır, böylece etiketlere doğru şekilde atanabilirler.

## unpairedTags
Eşleşmeyen Etiketler, eşleşen kapanış etiketi olmayan etiketlerdir. Örneğin HTML'deki ``. Eşleşmeyen etiketleri, listeyi ayrıştırıcı, doğrulayıcı ve oluşturucuya sağlayarak ayrıştırabilirsiniz.

Örnek
```js
const xmlData = `
    <rootNode>
        <tag>value</tag>
        <empty />
        <unpaired>
        <unpaired />
        <unpaired></unpaired>
    </rootNode>`;  

const options = {
    // suppressUnpairedNode: true,
    unpairedTags: ["unpaired"]
};
const parser = new XMLParser(options);
const result = parser.parse(xmlData);

const builder = new XMLBuilder(options);
const output = builder.build(result);
```
Çıktı
```xml
<rootNode>
  <tag>value</tag>
  <empty></empty>
  <unpaired>
  <unpaired>
  <unpaired>
</rootNode>
```

Artık `suppressUnpairedNode: false` ayarlarsanız, aşağıdaki çıktıyı alırsınız.

```xml
<rootNode>
  <tag>value</tag>
  <empty></empty>
  <unpaired/>
  <unpaired/>
  <unpaired/>
</rootNode>
```

# Orijinal XML'i Geri Yükleme

**Örnek 1**

`alwaysCreateTextNode: true` ile XML Ayrıştırıcıyı kullandığınızda, XMLBuilder sonuçlarını etkilemez.

```js
const XMLdata = `
      <car>
        <color>purple</color>
        <type>minivan</type>
        <registration>2020-02-03</registration>
        <capacity>7</capacity>
      </car>`;

const parser = new XMLParser({
    alwaysCreateTextNode: true,
});
let result = parser.parse(XMLdata);
// console.log(JSON.stringify(result, null,4));

const builder = new XMLBuilder({ format: true });
const output = builder.build(result);
```

Çıktı
```xml
<car>
  <color>purple</color>
  <type>minivan</type>
  <registration>2020-02-03</registration>
  <capacity>7</capacity>
</car>
```

**Örnek 2**

`isArray` ile XML Ayrıştırıcıyı kullandığınızda, belirli bir ölçüde XMLBuilder sonuçlarını etkilemez.

```js
const XMLdata = `
      <car>
        <color>purple</color>
        <type>minivan</type>
        <registration>2020-02-03</registration>
        <capacity>7</capacity>
      </car>`;

const parser = new XMLParser({
    isArray: (tagName, jPath, isLeafNode, isAttribute) => {
        if(isLeafNode) return true;
    }
});
let result = parser.parse(XMLdata);
// console.log(JSON.stringify(result, null,4));

const builder = new XMLBuilder();
const output = builder.build(result);
```

Çıktı
```xml
<car>
  <color>purple</color>
  <type>minivan</type>
  <registration>2020-02-03</registration>
  <capacity>7</capacity>
</car>
```

**Örnek 3**

XMLParser'ı `preserveOrder` ile kullandığınızda, XMLBuilder ile aynı seçeneği kullanmalısınız.

```js
const XMLdata = `
      <car>
        <color>purple</color>
        <type>minivan</type>
        <registration>2020-02-03</registration>
        <capacity>7</capacity>
      </car>`;

const parser = new XMLParser({
    preserveOrder: true
});
let result = parser.parse(XMLdata);
// console.log(JSON.stringify(result, null,4));

const builder = new XMLBuilder({ preserveOrder: true });
const output = builder.build(result);
```

Çıktı
```xml
<car>
  <color>purple</color>
  <type>minivan</type>
  <registration>2020-02-03</registration>
  <capacity>7</capacity>
</car>
```

**Örnek 4**

`attributeNamePrefix` ve diğer özellikleri XML Ayrıştırıcı ve XMLBuilder için aynı değere ayarlamalısınız.

```js
const XMLdata = `
<car>
    <color alpha="7">purple</color>
    <type>minivan</type>
    <registration>2020-02-03</registration>
    <capacity>7</capacity>
</car>`;

const options = {
    ignoreAttributes: false,
    attributeNamePrefix: "@@",
    format: true
};
const parser = new XMLParser(options);
let result = parser.parse(XMLdata);
// console.log(JSON.stringify(result, null,4));

const builder = new XMLBuilder(options);
const output = builder.build(result);
```

Çıktı
```xml
<car>
  <color alpha="7">purple</color>
  <type>minivan</type>
  <registration>2020-02-03</registration>
  <capacity>7</capacity>
</car>
```

`> İleri: XmlValidator`