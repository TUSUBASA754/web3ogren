---
title: XML Parser Options
description: This document explores various options available for customizing the XML parsing process using fast-xml-parser. It includes detailed examples and output formats.
keywords: [XML, parser, fast-xml-parser, options, JavaScript]
---

We can customize parsing by providing different options to the parser;

```js
const {XMLParser} = require('fast-xml-parser');

const options = {
    ignoreAttributes : false
};

const parser = new XMLParser(options);
let jsonObj = parser.parse(xmlDataStr);
```

Her bir seçeneği gerekli örneklerle daha ayrıntılı anlayalım.

## allowBooleanAttributes

Değer içermeyen niteliklere izin vermek için. 

Varsayılan olarak boolean nitelikler göz ardı edilir.

```js
const xmlDataStr = `<root a="nice" checked><a>wow</a></root>`;

const options = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_"
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "@_a": "nice",
        "a": "wow"
    }
}
```

> Boolean niteliklere izin verdiğinizde, bunlar ayrıştırılır ve `true` olarak ayarlanır.

```js
const xmlDataStr = `<root a="nice" checked><a>wow</a></root>`;

const options = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
    allowBooleanAttributes: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "@_a": "nice",
        "@_checked": true,
        "a": "wow"
    }
}
```

## alwaysCreateTextNode

:::tip 
FXP, `preserveOrder: true` olduğunda her zaman metin düğümü oluşturur. Aksi takdirde, değer doğrudan etiket adı ile bir özelliğe atanır.
:::

Bu seçeneği kullanarak FXP'yi metin düğümü ile bir etiketi oluşturması için zorlayabilirsiniz.

**Örnek:**
```js
const xmlDataStr = `
    <root a="nice" checked>
        <a>wow</a>
        <a>
          wow again
          <c> unlimited </c>
        </a>
        <b>wow phir se</b>
    </root>`;  

const options = {
    ignoreAttributes: false,
    // alwaysCreateTextNode: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**`alwaysCreateTextNode: false` iken çıktı**
```json
{
    "root": {
        "a": [
            "wow",
            {
                "c": "unlimited",
                "#text": "wow again"
            }
        ],
        "b": "wow phir se",
        "@_a": "nice"
    }
}
```

**`alwaysCreateTextNode: true` iken çıktı**
```json
{
    "root": {
        "a": [
            {
                "#text": "wow"
            },
            {
                "c": {
                    "#text": "unlimited"
                },
                "#text": "wow again"
            }
        ],
        "b": {
            "#text": "wow phir se"
        },
        "@_a": "nice"
    }
}
```

## attributesGroupName

Bir etiketin tüm niteliklerini verilen bir özellik adı altında gruplamak için.

```js
const xmlDataStr = `<root a="nice" b="very nice" ><a>wow</a></root>`;

const options = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
    attributesGroupName : "@_"
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "@_": {
            "@_a": "nice",
            "@_b": "very nice"
        },
        "a": "wow"
    }
}
```

---

## attributeNamePrefix

Nitelikleri JS nesnesinde ayrı olarak tanımak için her niteliğin adına bazı dize ekleyebilirsiniz.

```js
const xmlDataStr = `<root a="nice" ><a>wow</a></root>`;

const options = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_"
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "@_a": "nice",
        "a": "wow"
    }
}
```

## attributeValueProcessor

:::info
`tagValueProcessor` ile benzer ancak niteliklere uygulanır.
:::

**Örnek**

```js
const options = {
    ignoreAttributes: false,
    attributeValueProcessor: (name, val, jPath) => {
        :
    }
};
:
```

## cdataPropName

`cdataPropName` herhangi bir özellik adına ayarlanmazsa, CDATA değerleri etiketin metin değerine birleştirilir.

**Örnek**
```js
const xmlDataStr = `
    <a>
        <name>name:<![CDATA[<some>Jack</some>]]><![CDATA[Jack]]></name>
    </a>`;  

const parser = new XMLParser();
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "a": {
        "name": "name:<some>Jack</some>Jack"
    }
}
```

`cdataPropName` bir belirli özellik adına ayarlandığında, metin değeri ile CDATA farklı özelliklere ayrıştırılır.

**Örnek 2**
```js
const options = {
    cdataPropName:     "__cdata"
}
```

**Çıktı**
```json
{
    "a": {
        "name": {
            "__cdata": [
                "<some>Jack</some>",
                "Jack"
            ],
            "#text": "name:"
        }
    }
}
```

## commentPropName

`commentPropName` belirli bir özellik adına ayarlandığında, XML'den yorumlar ayrıştırılır.

**Örnek**
```js
const xmlDataStr = `
    <!--Öğrenci notları aylara göre yüklenmiştir-->
    <class_list>
       <student>
         <!--Öğrenci detayları-->
         <!--İkinci bir yorum-->
         <name>Tanmay</name>
         <grade>A</grade>
       </student>
    </class_list>`;  

const options = {
    commentPropName: "#comment"
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "#comment": "Öğrenci notları aylara göre yüklenmiştir",
    "class_list": {
        "student": {
            "#comment": [
                "Öğrenci detayları",
                "İkinci bir yorum"
            ],
            "name": "Tanmay",
            "grade": "A"
        }
    }
}
```

## htmlEntities

Varsayılan olarak FXP, `processEntities: true` olduğunda XML varlıklarını ayrıştırır. HTML varlıklarını ayrıştırmak için `htmlEntities` ayarını yapabilirsiniz.

Daha fazla bilgi için `varlıklar` bölümüne bakın.

## ignoreAttributes

Varsayılan olarak `ignoreAttributes` `true` ayarındadır. Bu, niteliklerin ayrıştırıcı tarafından göz ardı edildiği anlamına gelir. Niteliklere ilişkin herhangi bir yapılandırma ayarlarsanız ve `ignoreAttributes: false` ayarlı değilse, etkisi olmayacaktır.

### Seçici Nitelik Göz Ardı Etme

Belirli nitelikleri ayrıştırma veya oluşturma sırasında göz ardı etmek için dize, düzenli ifadeler veya geri çağırma işlevlerinden oluşan bir dizi belirtebilirsiniz.

### Örnek Girdi XML

```xml
<tag
    ns:attr1="a1-değeri"
    ns:attr2="a2-değeri"
    ns2:attr3="a3-değeri"
    ns2:attr4="a4-değeri">
        değer
</tag>
```

`ignoreAttributes` seçeneğini üç farklı şekilde kullanabilirsiniz:

1. **Dize Dizisi**: Belirli adlarla nitelikleri göz ardı etme.
2. **Düzenli İfadeler Dizisi**: Bir desene uyan nitelikleri göz ardı etme.
3. **Geri Çağırma Fonksiyonu**: Özelleştirilmiş mantığa dayanarak nitelikleri göz ardı etme.

### Örnek: Dize Dizisine Göre Nitelikleri Göz Ardı Etme

```js
const options = {
    attributeNamePrefix: "$",
    ignoreAttributes: ['ns:attr1', 'ns:attr2'],
    parseAttributeValue: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlData);
```

**Sonuç:**
```json
{
    "tag": {
        "#text": "değer",
        "$ns2:attr3": "a3-değeri",
        "$ns2:attr4": "a4-değeri"
    }
}
```

### Örnek: Düzenli İfade ile Nitelikleri Göz Ardı Etme

```js
const options = {
    attributeNamePrefix: "$",
    ignoreAttributes: [/^ns2:/],
    parseAttributeValue: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlData);
```

**Sonuç:**
```json
{
    "tag": {
        "#text": "değer",
        "$ns:attr1": "a1-değeri",
        "$ns:attr2": "a2-değeri"
    }
}
```

### Örnek: Geri Çağırma Fonksiyonu ile Nitelikleri Göz Ardı Etme

```js
const options = {
    attributeNamePrefix: "$",
    ignoreAttributes: (aName, jPath) => aName.startsWith('ns:') || jPath === 'tag.tag2',
    parseAttributeValue: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlData);
```

**Sonuç:**
```json
{
    "tag": {
        "$ns2:attr3": "a3-değeri",
        "$ns2:attr4": "a4-değeri",
        "tag2": "değer"
    }
}
```

## ignoreDeclaration

Birçok kullanıcı, XML açıklama etiketinin ayrıştırma çıktısından göz ardı edilmesini istediği için `ignoreDeclaration: true` ayarlayabilirler.

**Örnek**
```js
const xmlDataStr = `<?xml version="1.0"?>
      <?elementnames <fred>, <bert>, <harry> ?>
      <h1></h1>`;

const options = {
    ignoreDeclaration: true,
    attributeNamePrefix : "@_"
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "?elementnames": "",
    "h1": ""
}
```

## ignorePiTags

Birçok kullanıcı, PI etiketlerinin ayrıştırma çıktısından göz ardı edilmesini istediği için `ignorePiTags: true` ayarını yapabilirler.

**Örnek**
```js
const xmlDataStr = `<?xml version="1.0"?>
      <?elementnames <fred>, <bert>, <harry> ?>
      <h1></h1>`;

const options = {
    ignoreDeclaration: true,
    ignorePiTags: true,
    attributeNamePrefix : "@_"
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "h1": ""
}
```

## isArray

Tek bir etiketin dizi veya nesne olarak ayrıştırılıp ayrıştırılmayacağı, FXP tarafından belirlenemez. Bu nedenle `isArray` yöntemi, bir etiketin dizi olarak ayrıştırılıp ayrıştırılmayacağına karar vermeye yardımcı olabilir.

**Örnek**

```js
const xmlDataStr = `
    <root a="nice" checked>
        <a>wow</a>
        <a>
          wow again
          <c> unlimited </c>
        </a>
        <b>wow phir se</b>
    </root>`;

const alwaysArray = [
    "root.a.c",
    "root.b"
];
      

const options = {
    ignoreAttributes: false,
    isArray: (name, jpath, isLeafNode, isAttribute) => { 
        if( alwaysArray.indexOf(jpath) !== -1) return true;
    }
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "@_a": "nice",
        "a": [
            "wow",
            {
                "#text": "wow again",
                "c": [
                    "unlimited"
                ]
            }
        ],
        "b": [
            "wow phir se"
        ]
    }
}
```

## numberParseOptions

FXP, dizeyi sayıya ayrıştırmak için [strnum](https://github.com/NaturalIntelligence/strnum) kütüphanesini kullanır. Bu özellik, strnum paketinin yapılandırmasını ayarlamanıza olanak tanır.

**Örnek**
```js
const xmlDataStr = `
    <root>
        <a>-0x2f</a>
        <a>006</a>
        <a>6.00</a>
        <a>-01.0E2</a>
        <a>+1212121212</a>
    </root>`;  

const options = {
    numberParseOptions: {
        leadingZeros: true,
        hex: true,
        skipLike: /\+[0-9]{10}/,
        // eNotation: false
    }
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "a": [ -47, 6, 6, -100, "+1212121212" ],
    }
}
```

## parseAttributeValue

`parseAttributeValue: true` seçeneği, nitelik değerlerini ayrıştırmak için ayarlanabilir. Bu seçenek, sayısal değerleri ayrıştırmak için [strnum](https://github.com/NaturalIntelligence/strnum) paketini kullanır. Daha kontrollü ayrıştırma için `numberParseOptions` seçeneğine bakın.

**Örnek**
```js
const xmlDataStr = `
    <root a="nice" checked enabled="true" int="32" int="34">
        <a>wow</a>
    </root>`;  

const options = {
    ignoreAttributes: false,
    // parseAttributeValue: true,
    allowBooleanAttributes: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "a": "wow",
        "@_a": "nice",
        "@_checked": true,
        "@_enabled": "true",
        "@_int": "34"
    }
}
```

Boolean nitelikler her zaman `true` olarak ayrıştırılır. XML Ayrıştırıcı, doğrulama kapatıldığında hata vermez, bu nedenle tekrarlanabilir niteliklerin değerini geçersiz kılar.

**`parseAttributeValue: true` ayarlandığında**
```json
{
    "root": {
        "a": "wow",
        "@_a": "nice",
        "@_checked": true,
        "@_enabled": true,
        "@_int": 34
    }
}
```

Doğrulama seçenekleri ayarlandığında veya `true` olduğunda.

```js
//..
const output = parser.parse(xmlDataStr, {
    allowBooleanAttributes: true
});
//..
```

**Çıktı**
```bash
Error: Attribute 'int' is repeated.:1:48
```

## parseTagValue

`parseTagValue: true` seçeneği, etiket değerlerini ayrıştırmak için ayarlanabilir. Bu seçenek, sayısal değerleri ayrıştırmak için [strnum](https://github.com/NaturalIntelligence/strnum) paketini kullanır. Daha kontrollü ayrıştırma için `numberParseOptions` seçeneğine bakın.

**Örnek**
```js
const xmlDataStr = `
    <root>
        35<nested>34</nested>
    </root>`;  

const options = {
    parseTagValue: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": 35
}
```

**Örnek 2**
**Girdi**
```xml
<root>
    35<nested>34</nested>
</root>
```

**Çıktı**
```json
{
    "root": {
        "nested": 34,
        "#text": 35
    }
}
```

**Örnek 3**
**Girdi**
```xml
<root>
    35<nested>34</nested>46
</root>
```

**Çıktı**
```json
{
    "root": {
        "nested": 34,
        "#text": "3546"
    }
}
```

## preserveOrder

`preserveOrder: true` ayarlandığında, bazı uzun çirkin sonuçlar alırsınız. Bunun nedeni, bu seçeneğin, sonuç JS nesnesindeki etiketlerin sırasını korumak için kullanılmasıdır. Bu, XML oluşturucunun, bilgi kaybı olmadan, JS nesnesinden benzer bir XML oluşturmasına da yardımcı olur.

```js
const XMLdata = `
    <!--Öğrenci notları aylara göre yüklenmiştir-->
    <class_list standard="3">
       <student>
         <!--Öğrenci detayları-->
         <!--İkinci bir yorum-->
         <name>Tanmay</name>
         <grade>A</grade>
       </student>
    </class_list>`;

const options = {
    commentPropName: "#comment",
    preserveOrder: true
};
const parser = new XMLParser(options);
let result = parser.parse(XMLdata);
```
```json
[
    {
        "#comment": [
            { "#text": "Öğrenci notları aylara göre yüklenmiştir" }
        ]
    },
    {
        "class_list": [
            {
                "student": [
                    {
                        "#comment": [
                            { "#text": "Öğrenci detayları" }
                        ]
                    },
                    {
                        "#comment": [
                            { "#text": "İkinci bir yorum" }
                        ]
                    },
                    {
                        "name": [
                            { "#text": "Tanmay" }
                        ]
                    },
                    {
                        "grade": [
                            { "#text": "A" }
                        ]
                    }
                ]
            }
        ],
        ":@": {
            "standard" : "3"
        }
    }
]
```

## processEntities

Varsayılan olarak `true` olarak ayarlanır, varsayılan ve DOCTYPE varlıklarını işlemek için. Daha fazla ayrıntı için `Varlıklar` bölümüne bakın. XML belgenizde varlık yoksa, daha iyi performans için `processEntities: false` ayarlamanız önerilir.

## removeNSPrefix

Etiket ve niteliğin adlarından ad alanı dizesini kaldırır.

Varsayılan, `removeNSPrefix: false`'dır.

```js
const xmlDataStr = `<root some:a="nice" ><any:a>wow</any:a></root>`;

const options = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_"
    //removeNSPrefix: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "@_some:a": "nice",
        "any:a": "wow"
    }
}
```

`removeNSPrefix: true` ayarlandığında
```js
const xmlDataStr = `<root some:a="nice" ><any:a>wow</any:a></root>`;

const options = {
    ignoreAttributes: false,
    attributeNamePrefix : "@_",
    removeNSPrefix: true
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "@_a": "nice",
        "a": "wow"
    }
}
```

## stopNodes

Belirli bir noktada, bir etiketi ve iç içe geçmiş etiketlerini ayrıştırmak istemiyorsanız `stopNodes` içerisinde yollarını ayarlayabilirsiniz.

**Örnek**
```js
const xmlDataStr = `
    <root a="nice" checked>
        <a>wow</a>
        <a>
          wow again
          <c> unlimited </c>
        </a>
        <b>wow phir se</b>
    </root>`;  

const options = {
    stopNodes: ["root.a"]
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "a": [
            "wow",
            "\n            wow again\n            <c> unlimited </c>\n          "
        ],
        "b": "wow phir se"
    }
}
```

Ayrıca işlenmeyen bir etiket belirtmek istiyorsanız, herhangi bir yolun etkisi olmamalıdır. Örneğin, bir HTML belgesindeki `` veya `` etiketi.

```js
const options = {
    stopNodes: ["*.pre", "*.script"]
};
```

Dikkat edin ki bir durdurma düğümü, içeriklerindeki aynı kapama düğümüne sahip olmamalıdır. Örneğin:

```xml
<stop>
invalid </stop>
</stop>
```

İç içe geçmiş durdurma düğümleri de yasaktır.
```xml
<stop>
    <stop> invalid </stop>
</stop>
```

## tagValueProcessor

`tagValueProcessor` ile hangi etiket değerinin nasıl ayrıştırılacağını kontrol edebilirsiniz.

1. Eğer `tagValueProcessor` `undefined` veya `null` dönerse, orijinal değer ayrıştırılmadan ayarlanır.
2. Eğer farklı bir değer veya farklı veri tipi dönerse, yeni değer ayrıştırılmadan ayarlanır.
3. Aksi takdirde, orijinal değer ayrıştırma (eğer `parseTagValue: true` ise) sonrası ayarlanır.
4. Eğer etiket değeri boşsa, `tagValueProcessor` çağrılmayacaktır.

**Örnek**
```js
const xmlDataStr = `
    <root a="nice" checked>
        <a>wow</a>
        <a>
          wow again
          <c> unlimited </c>
        </a>
        <b>wow phir se</b>
    </root>`;  

const options = {
    ignoreAttributes: false,
    tagValueProcessor: (tagName, tagValue, jPath, hasAttributes, isLeafNode) => {
        if(isLeafNode) return tagValue;
        return "";
    }
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "a": [
            {
                "#text": "wow",
                "@_a": "2"
            },
            {
                "c": {
                    "#text": "unlimited",
                    "@_a": "2"
                },
                "@_a": "2"
            }
        ],
        "b": {
            "#text": "wow phir se",
            "@_a": "2"
        },
        "@_a": "nice"
    }
}
```

## textNodeName

Bir etiketin metin değeri varsayılan olarak `#text` özelliğine ayrıştırılır. Bunu her zaman değiştirebilirsiniz.

**Örnek**
```js
const xmlDataStr = `
    <a>
            text<b>alpha</b>
    </a>`;  

const options = {
    ignoreAttributes: false,
    textNodeName: "$text"
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "a": {
        "b": "alpha",
        "$text": "text"
    }
}
```

## transformTagName

`transformTagName` özellik işlevi, bir etiket adını ihtiyaçlarınız doğrultusunda değiştirmeyi sağlar. Örneğin, 'red-code' 'redCode' ya da 'redCode' 'redcode' olarak dönüştürülmek istenebilir.

```js
transformTagName: (tagName) => tagName.toLowerCase()
```

## transformAttributeName

`transformAttributeName` özellik işlevi, niteliğin adını değiştirmeye olanak tanır.

```js
transformAttributeName: (attributeName) => attributeName.toLowerCase()
```

## trimValues

Etiket veya niteliğin değerinden çevresindeki boşlukları kaldırır.

**Örnek**
```js
const xmlDataStr = `
    <root attri="  ibu  te   ">
        35       <nested>   34</nested>
    </root>`;  

const options = {
    ignoreAttributes: false,
    parseTagValue: true, //varsayılan
    trimValues: false
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

**Çıktı**
```json
{
    "root": {
        "nested": 34,
        "#text": "\n      35       \n    ",
        "@_attri": "  ibu  te   "
    }
}
```

Eğer etiket değeri yalnızca boşluklardan oluşuyorsa ve `trimValues: false` ise, değer ayrıştırılmayacaktır, hatta `parseTagValue: true` olmasına rağmen. Benzer şekilde, `trimValues: true` ve `parseTagValue: false` durumunda çevresindeki boşluklar kaldırılmayacaktır.

```js
const options = {
    ignoreAttributes: false,
    parseTagValue: false,
    trimValues: true //varsayılan
};
```

**Çıktı**
```json
{
    "root": {
        "nested": "34",
        "#text": "35",
        "@_attri": "ibu  te"
    }
}
```

---
title: uyumsuzEtiketler
description: Uyumsuz Etiketler, eşleşmeyen kapanış etiketleri ve bunların nasıl işlenmesi gerektiği hakkında bilgi verir. XML parsing sırasında dikkate alınması gereken önemli noktaları içerir.
keywords: [Uyumsuz Etiketler, HTML, XML, Parser, Validator, Kapanış Etiketi, Parsing]
---

## uyumsuzEtiketler

Uyumsuz Etiketler, eşleşen bir kapanış etiketi olmayan etiketlerdir. Örneğin, HTML'deki `` etiketi. Parser, validator ve builder'a uyumsuz etiketlerin listesini vererek uyumsuz etiketleri ayrıştırabilirsiniz.

:::info
Uyumsuz etiketler, XML yapısının geçerliliği açısından kritik öneme sahiptir. Bu nedenle, parser ayarlarında doğru şekilde tanımlanmalıdır.
:::

### Örnek

```js
const xmlDataStr = `
    <rootNode>
        <tag>value</tag>
        <empty />
        <unpaired>
        <unpaired />
        <unpaired>

    </rootNode>`;  
const options = {
    unpairedTags: ["unpaired"]
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

### Çıktı

```json
{
    "rootNode": {
        "tag": "value",
        "empty": "",
        "unpaired": [ "", "", ""]
    }
}
```

> **Not**: Uyumsuz etiketler kapanış etiketi olarak kullanılamaz; örneğin `` kullanılamaz.  
> — XML Dokümantasyonu

---

## etiketGüncelle

Bu özellik, farklı bir isim gönderdiğinizde etiket adını değiştirmenizi, parsing sonucundan bir etiketi atlamanızı sağlayarak false döndüğünüzde veya özellikleri değiştirmeyi mümkün kılar.

```js
const xmlDataStr = `
    <rootNode>
        <a at="val">value</a>
        <b></b>
    </rootNode>`;  

const options = {
    attributeNamePrefix: "",
    ignoreAttributes:    false,
    updateTag(tagName, jPath, attrs){
        attrs["At"] = "Ev";
        delete attrs["at"];
        
        if(tagName === "a") return "A";
        else if(tagName === "b") return false;
    }
};
const parser = new XMLParser(options);
const output = parser.parse(xmlDataStr);
```

`> Sonraki: XmlBuilder`